# PRD: FEFF10 True-Compute Rust Rewrite (No Fortran Runtime)

## 1. Introduction/Overview

This project rewrites FEFF10 into Rust as a true-compute implementation, with all production scientific computation executed by Rust code. The migration must preserve user-visible behavior and scientific outputs within approved numeric tolerances while allowing aggressive architectural refactoring for long-term maintainability.

This PRD sets strict boundaries:
- No Fortran runtime execution in the Rust binary at any migration stage.
- No Fortran-linked fallback path in production commands.
- Dual-run parity validation against a Fortran oracle remains required for acceptance, but oracle execution exists only in validation tooling, not in runtime execution.
- MPI parity is deferred to a post-v1 roadmap.

## 2. Goals

- G-1: Deliver true Rust scientific computation for all in-scope FEFF10 modules.
- G-2: Eliminate Fortran runtime dependencies from production execution paths from day one.
- G-3: Preserve scientific equivalence to FEFF10 within approved numeric tolerances.
- G-4: Preserve compatibility contracts for CLI surfaces, required artifacts, directory conventions, and deterministic error signaling.
- G-5: Complete an aggressive architecture refactor that improves maintainability, testability, and extensibility.
- G-6: Enforce release-blocking parity through dual-run Fortran oracle validation plus fixture-based comparison policy.

## 3. User Stories

### US-001: Lock migration constraints and acceptance gates
**Description:** As a migration lead, I want fixed rewrite constraints so implementation decisions remain consistent across all module ports.

**Acceptance Criteria:**
- [ ] A single migration constraints document defines "Rust-only runtime", "true compute", and "no Fortran fallback" as mandatory.
- [ ] Release-blocking parity policy explicitly requires dual-run oracle checks.
- [ ] MPI deferment is documented as out-of-scope for v1 runtime parity.
- [ ] Typecheck/lint passes for touched Rust tooling code.

### US-002: Define aggressive target architecture
**Description:** As a maintainer, I want a long-term Rust architecture so module rewrites are coherent and maintainable.

**Acceptance Criteria:**
- [ ] Target architecture maps legacy FEFF10 responsibilities into Rust crates/modules with clear ownership.
- [ ] Shared interfaces are defined for parser model, numerics, module inputs, module outputs, and diagnostics.
- [ ] Architecture includes deterministic I/O boundaries and serialization rules.
- [ ] Architecture rejects baseline-copy execution as a runtime module strategy.
- [ ] Typecheck/lint passes.

### US-003: Build oracle validation pipeline (non-runtime)
**Description:** As a release engineer, I want a dual-run oracle harness so Rust output parity can be proven before release.

**Acceptance Criteria:**
- [ ] Validation tooling can execute Fortran reference runs and Rust runs for the same fixture inputs.
- [ ] Comparator reports include machine-readable and human-readable diff outputs.
- [ ] Validation tooling is isolated from production runtime commands.
- [ ] CI can fail a build when oracle parity thresholds are not met.
- [ ] Typecheck/lint passes.

### US-004: Port parser to production-ready Rust model
**Description:** As a migration engineer, I want a robust Rust parser so all module ports consume a stable typed input model.

**Acceptance Criteria:**
- [ ] Parser supports all cards/constructs used by approved fixtures.
- [ ] Parser emits deterministic, categorized validation errors.
- [ ] Snapshot tests cover accepted and rejected input decks.
- [ ] Typecheck/lint passes.

### US-005: Port shared numerics foundation
**Description:** As a migration engineer, I want trusted numeric primitives so module compute code is reproducible and testable.

**Acceptance Criteria:**
- [ ] Required core math primitives are implemented in Rust with deterministic behavior.
- [ ] Numeric tolerance and formatting behavior follows approved policy.
- [ ] Reference-data tests validate numerics against known expected values.
- [ ] Typecheck/lint passes.

### US-006: Implement deterministic artifact I/O framework
**Description:** As a module developer, I want shared artifact readers/writers so module outputs are stable and contract-compliant.

**Acceptance Criteria:**
- [ ] Shared I/O utilities support text and binary artifact contracts required by all in-scope modules.
- [ ] Output serialization is deterministic for repeated runs on same input/environment.
- [ ] Error paths preserve compatibility exit-code categories and diagnostic format.
- [ ] Typecheck/lint passes.

### US-007: Rewrite RDINP as true-compute Rust implementation
**Description:** As a user, I want `RDINP` fully computed in Rust so upstream module inputs are generated without Fortran dependencies.

**Acceptance Criteria:**
- [ ] `RDINP` outputs required by compatibility matrix are generated by Rust compute logic.
- [ ] Dual-run oracle parity passes for all `RDINP` fixtures.
- [ ] Module regression tests validate output contracts and error behavior.
- [ ] Typecheck/lint passes.

### US-008: Rewrite POT as true-compute Rust implementation
**Description:** As a user, I want `POT` computed in Rust so potential generation no longer depends on copied baselines.

**Acceptance Criteria:**
- [ ] `POT` runtime path does not read baseline outputs for artifact materialization.
- [ ] Rust `POT` computes and writes required artifacts using Rust logic only.
- [ ] Dual-run oracle parity passes for approved `POT` fixtures.
- [ ] Typecheck/lint passes.

### US-009: Rewrite XSPH as true-compute Rust implementation
**Description:** As a user, I want `XSPH` computed in Rust so phase and spectral artifacts are produced by native code.

**Acceptance Criteria:**
- [ ] Rust `XSPH` computes required outputs without baseline-copy behavior.
- [ ] Optional-input behavior remains compatibility-compliant.
- [ ] Dual-run oracle parity passes for approved `XSPH` fixtures.
- [ ] Typecheck/lint passes.

### US-010: Rewrite PATH as true-compute Rust implementation
**Description:** As a user, I want `PATH` computed in Rust so path enumeration and ordering are native.

**Acceptance Criteria:**
- [ ] Rust `PATH` computes required path artifacts from staged inputs.
- [ ] Path ordering and filtering behavior matches compatibility contracts.
- [ ] Dual-run oracle parity passes for approved `PATH` fixtures.
- [ ] Typecheck/lint passes.

### US-011: Rewrite FMS as true-compute Rust implementation
**Description:** As a user, I want `FMS` computed in Rust so scattering outputs are generated natively.

**Acceptance Criteria:**
- [ ] Rust `FMS` compute path produces required `FMS` artifacts without baseline output copies.
- [ ] Input and error handling remain compatibility-compliant.
- [ ] Dual-run oracle parity passes for approved `FMS` fixtures.
- [ ] Typecheck/lint passes.

### US-012: Rewrite BAND as true-compute Rust implementation
**Description:** As a user, I want `BAND` computed in Rust so bandstructure outputs are native.

**Acceptance Criteria:**
- [ ] Rust `BAND` generates required outputs from module inputs with no baseline-copy runtime behavior.
- [ ] Fixture coverage includes baseline-capture edge cases for missing reference archives.
- [ ] Dual-run oracle parity passes for approved `BAND` fixtures.
- [ ] Typecheck/lint passes.

### US-013: Rewrite LDOS as true-compute Rust implementation
**Description:** As a user, I want `LDOS` computed in Rust so density-of-states outputs are natively generated.

**Acceptance Criteria:**
- [ ] Rust `LDOS` computes required `ldos*.dat` output family and logs.
- [ ] Output file set handling remains fixture-aware and contract-compliant.
- [ ] Dual-run oracle parity passes for approved `LDOS` fixtures.
- [ ] Typecheck/lint passes.

### US-014: Rewrite RIXS as true-compute Rust implementation
**Description:** As a user, I want `RIXS` computed in Rust so multi-edge spectral outputs are native.

**Acceptance Criteria:**
- [ ] Rust `RIXS` computes required outputs from staged multi-edge inputs.
- [ ] Optional/fixture-specific output variants remain compatibility-compliant.
- [ ] Dual-run oracle parity passes for approved `RIXS` fixtures.
- [ ] Typecheck/lint passes.

### US-015: Rewrite CRPA as true-compute Rust implementation
**Description:** As a user, I want `CRPA` computed in Rust so screening outputs are generated natively.

**Acceptance Criteria:**
- [ ] Rust `CRPA` computes required artifacts from declared module inputs.
- [ ] Output contracts and diagnostics follow compatibility requirements.
- [ ] Dual-run oracle parity passes for approved `CRPA` fixtures.
- [ ] Typecheck/lint passes.

### US-016: Rewrite COMPTON as true-compute Rust implementation
**Description:** As a user, I want `COMPTON` computed in Rust so Compton outputs are generated natively.

**Acceptance Criteria:**
- [ ] Rust `COMPTON` computes required output artifacts using native compute logic.
- [ ] Binary/text input handling matches compatibility contracts.
- [ ] Dual-run oracle parity passes for approved `COMPTON` fixtures.
- [ ] Typecheck/lint passes.

### US-017: Rewrite DEBYE as true-compute Rust implementation
**Description:** As a user, I want `DEBYE` computed in Rust so thermal damping outputs are native.

**Acceptance Criteria:**
- [ ] Rust `DEBYE` computes required outputs including optional spring-driven artifacts where applicable.
- [ ] Optional-input behavior remains compatibility-compliant.
- [ ] Dual-run oracle parity passes for approved `DEBYE` fixtures.
- [ ] Typecheck/lint passes.

### US-018: Rewrite DMDW as true-compute Rust implementation
**Description:** As a user, I want `DMDW` computed in Rust so vibrational damping outputs are generated natively.

**Acceptance Criteria:**
- [ ] Rust `DMDW` computes required output artifacts without baseline materialization.
- [ ] Mixed binary/text input behavior matches expected contracts.
- [ ] Dual-run oracle parity passes for approved `DMDW` fixtures.
- [ ] Typecheck/lint passes.

### US-019: Rewrite SCREEN as true-compute Rust implementation
**Description:** As a user, I want `SCREEN` computed in Rust so screened-core-hole outputs are native.

**Acceptance Criteria:**
- [ ] Rust `SCREEN` computes required outputs from staged inputs and optional overrides.
- [ ] Error behavior and diagnostics remain compatibility-compliant.
- [ ] Dual-run oracle parity passes for approved `SCREEN` fixtures.
- [ ] Typecheck/lint passes.

### US-020: Rewrite SELF as true-compute Rust implementation
**Description:** As a user, I want `SELF` computed in Rust so self-energy outputs are generated natively.

**Acceptance Criteria:**
- [ ] Rust `SELF` enforces one-of spectrum input requirements and computes required outputs.
- [ ] Optional-input handling remains compatibility-compliant.
- [ ] Dual-run oracle parity passes for approved `SELF` fixtures.
- [ ] Typecheck/lint passes.

### US-021: Rewrite EELS as true-compute Rust implementation
**Description:** As a user, I want `EELS` computed in Rust so ELNES outputs are generated natively.

**Acceptance Criteria:**
- [ ] Rust `EELS` computes required outputs without baseline-copy execution.
- [ ] Optional magic-angle input behavior remains compatibility-compliant.
- [ ] Dual-run oracle parity passes for approved `EELS` fixtures.
- [ ] Typecheck/lint passes.

### US-022: Rewrite FULLSPECTRUM as true-compute Rust implementation
**Description:** As a user, I want `FULLSPECTRUM` computed in Rust so full-spectrum outputs are generated natively.

**Acceptance Criteria:**
- [ ] Rust `FULLSPECTRUM` computes required outputs and preserves supported optional overlays.
- [ ] Output contract remains compatible with approved fixtures.
- [ ] Dual-run oracle parity passes for approved `FULLSPECTRUM` fixtures.
- [ ] Typecheck/lint passes.

### US-023: Remove baseline-copy module runtime behavior
**Description:** As a maintainer, I want to remove baseline-copy execution so production output always comes from Rust computation.

**Acceptance Criteria:**
- [ ] No production pipeline execution path materializes outputs by copying baseline fixture files.
- [ ] Baseline artifacts remain only as regression comparison references.
- [ ] Regression and CLI tests fail if baseline-copy execution is reintroduced.
- [ ] Typecheck/lint passes.

### US-024: Harden CI release gates for true-compute parity
**Description:** As a release owner, I want strict CI gates so only true-compute parity-safe changes can merge.

**Acceptance Criteria:**
- [ ] Quality gates run `cargo check`, `cargo test`, `cargo clippy -- -D warnings`, and `cargo fmt --check`.
- [ ] Protected branch parity gate requires dual-run oracle checks for migrated modules.
- [ ] Failure artifacts include machine-readable report and human-readable mismatch summary.
- [ ] Typecheck/lint passes for any touched CI tooling.

### US-025: Execute cutover and rollback rehearsal with true-compute binaries
**Description:** As an operator, I want rehearsed cutover and rollback steps so release risk is controlled.

**Acceptance Criteria:**
- [ ] Cutover rehearsal uses true-compute Rust binaries and validates required workflow outputs.
- [ ] Rollback rehearsal validates restoration to last stable Fortran artifact bundle.
- [ ] GA readiness report includes parity evidence from true-compute implementation.
- [ ] Typecheck/lint passes for touched scripts/tooling.

## 4. Functional Requirements

- FR-1: The system must execute all production scientific module computation in Rust.
- FR-2: The system must not invoke Fortran binaries/libraries at runtime for any production CLI command.
- FR-3: The system must preserve FEFF-compatible CLI commands and argument contracts.
- FR-4: The system must preserve required output artifact names and locations per compatibility matrix.
- FR-5: The system must preserve deterministic diagnostic formatting and exit-code categories.
- FR-6: The parser must accept all fixture-backed FEFF input constructs required by in-scope modules.
- FR-7: The parser must emit deterministic validation errors for invalid input decks.
- FR-8: Shared numerics must implement deterministic primitives required by module computations.
- FR-9: Numeric formatting and tolerance logic must follow approved policy definitions.
- FR-10: Each module rewrite must provide Rust-native computation for its required outputs.
- FR-11: `RDINP` must generate downstream module input artifacts using Rust logic.
- FR-12: `POT` must generate potential outputs using Rust logic only.
- FR-13: `XSPH` must generate phase and cross-section outputs using Rust logic only.
- FR-14: `PATH` must compute path outputs, including ordering/filtering behavior, using Rust logic only.
- FR-15: `FMS` must compute scattering outputs using Rust logic only.
- FR-16: `BAND` must compute band outputs using Rust logic only.
- FR-17: `LDOS` must compute LDOS output families using Rust logic only.
- FR-18: `RIXS` must compute multi-edge spectral outputs using Rust logic only.
- FR-19: `CRPA`, `COMPTON`, `DEBYE`, `DMDW`, `SCREEN`, `SELF`, `EELS`, and `FULLSPECTRUM` must each compute required outputs using Rust logic only.
- FR-20: Production pipelines must not copy baseline artifacts as output-generation strategy.
- FR-21: Regression tooling must support dual-run Fortran oracle validation for release-blocking parity checks.
- FR-22: Oracle tooling must be isolated from production runtime code paths.
- FR-23: CI must fail on parity regressions against approved oracle/tolerance gates.
- FR-24: CI must publish parity diff artifacts when parity checks fail.
- FR-25: The migration must support aggressive refactoring while preserving user-visible contracts.
- FR-26: MPI runtime parity must remain out-of-scope for v1 and clearly documented as deferred.
- FR-27: Any intentional compatibility deviation must be explicitly documented and approved before release.

## 5. Non-Goals (Out of Scope)

- Implementing MPI-distributed scientific parity in v1 runtime.
- Adding new scientific models that do not exist in FEFF10 baseline scope.
- Building GUI/web frontends.
- Maintaining hybrid production runtime modes that execute Fortran for module fallback.
- Guaranteeing bitwise-identical outputs across all architectures.

## 6. Design Considerations

- Use aggressive domain-oriented refactoring to replace legacy structure where it improves clarity and testability.
- Keep explicit module contracts for required inputs, generated outputs, and failure classes.
- Enforce deterministic serialization for both text and binary artifact writers.
- Centralize compatibility diagnostics and exit-code mapping in shared domain error types.

## 7. Technical Considerations

- Architecture should separate parser model, numerics, scientific engines, I/O adapters, and CLI orchestration.
- Ensure no runtime linkage to Fortran libraries and no shell-outs to Fortran executables from production commands.
- Build oracle tooling as an offline validation path used by CI and release qualification only.
- Preserve serial execution semantics in v1 while keeping orchestration seams for future MPI work.
- Expand fixture coverage where baseline capture is incomplete and where module edge cases are underrepresented.
- Define deterministic floating-point handling, token parsing, and line-ending normalization behavior across platforms.

## 8. Success Metrics

- SM-1: 100% of in-scope modules execute true-compute Rust code paths in production.
- SM-2: 0 production runtime paths invoke Fortran binaries/libraries.
- SM-3: 100% pass on release-blocking dual-run oracle parity checks for approved fixtures.
- SM-4: 100% pass on quality gates (`check`, `test`, `clippy`, `fmt`) in CI.
- SM-5: 0 critical compatibility regressions in cutover rehearsal.
- SM-6: Fortran compiler is not required in the primary Rust release build/test pipeline.

## 9. Open Questions

- OQ-1: What timeline and staffing allocation is approved for aggressive full-stack refactor plus full module rewrite?
- OQ-2: Should performance objectives be set per module or only per end-to-end workflows?
- OQ-3: Which fixtures should be expanded first to strengthen oracle confidence for complex modules (`RIXS`, `FULLSPECTRUM`, `COMPTON`)?

