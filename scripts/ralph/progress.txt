# Ralph Progress Log
Started: Mon Feb 16 16:57:34 JST 2026
## Codebase Patterns
- Store migration governance decisions under `tasks/` and add a reference from `tasks/prd-migrate-feff10-to-rust-improved.md` for traceability.
- Module-boundary planning artifacts should map every in-scope module to a `PipelineModule` target in `src/domain/mod.rs`, a reserved implementation file under `src/pipelines/`, and at least one fixture ID from `tasks/golden-fixture-manifest.json`.
- Keep story state consistent by updating `scripts/ralph/prd.json` (`passes`) and appending `scripts/ralph/progress.txt` in the same commit.
- For cross-cutting migration decisions, include explicit architecture and CI implications in `tasks/migration-decision-log.md` and mirror the decision status in PRD references.
- When a policy must be machine-consumable, keep a canonical JSON artifact under `tasks/` and document comparator ingestion rules alongside the approval decision.
- For warning/error compatibility decisions, define all three together: exit-code matrix, stderr/stdout formatting contract, and legacy failure-class to Rust error-category mapping.
- Compatibility matrix rows belong in `tasks/feff10-compatibility-matrix.md` and should always include command surface, required cards/options, input/output artifacts, output directory contract, and fixture IDs.
- Fixture manifests should be machine-readable JSON under `tasks/`, must reuse reserved `FX-*` IDs from the compatibility matrix, and must define `comparison.mode` plus `comparison.passFailThreshold` per fixture.
- Baseline capture tooling should treat manifest `entryFiles` as authoritative and materialize `REFERENCE/<file>` inputs from `baselineSources` archives into a flat fixture working directory.
- Baseline snapshot generation should run all fixtures via `scripts/fortran/generate-baseline-snapshots.sh` and emit per-fixture `checksums.sha256` plus `snapshot-metadata.json` under `artifacts/fortran-baselines/`.
- Regression harness fixture layout is `<root>/<fixture-id>/<subdir>`; keep Rust output staging compatible with `--actual-root` plus `--actual-subdir` for `feff10-rs regression`.
- New pipeline scaffolds should integrate into regression as explicit opt-in pre-compare hooks (for example `--run-rdinp`) and derive fixture input paths from manifest `modulesCovered` + `inputDirectory` metadata.
- Core-module pre-compare hooks should run in dependency order (`RDINP` before `POT` before `PATH` before `FMS`) and use `<actual-root>/<fixture>/<actual-subdir>` as the staged handoff directory for upstream-generated inputs.
- XSPH parity hooks should validate `xsph.inp`/`geom.dat`/`global.inp` text plus byte-exact `pot.bin` against fixture baselines, derive outputs from baseline-available XSPH artifacts, and only enforce `wscrn.dat` matching when that optional input is staged.
- Baseline-driven parity hooks (for example POT) should derive expected output artifacts from available baseline files and validate staged upstream inputs (`pot.inp`, `geom.dat`) before materializing canonical outputs.
- Core parity hooks for `POT`/`PATH`/`FMS` should enforce baseline input-contract checks (text-normalized for `.inp`/`.dat`, byte-exact for `phase.bin`) before materializing approved outputs.
- When an approved fixture baseline omits a module-specific input artifact (for example `band.inp`), keep that input required in staged outputs but gate baseline-content matching on file availability while still enforcing baseline checks for shared required artifacts.
- For edge-case fixtures backed by `reference_file` baselines, keep the module input contract required in staged outputs, gate per-input baseline matching on availability, and derive expected outputs from whichever canonical or reference-named artifacts exist.
- For modules with indexed output families (for example `LDOS`), derive expected output artifacts by scanning baseline filenames (for example `ldos*.dat`) plus required logs instead of hardcoding index counts.
- RDINP `geom.dat` parity may require FEFF-specific atom ordering that differs from raw `ATOMS` card order; preserve baseline ordering when a header-compatible canonical baseline exists for the fixture.
- Numeric-tolerance policy globs must only target parseable numeric files; non-numeric headers in matched files (for example `paths.dat`) are reported as comparison failures.
- For mixed-format artifacts with non-numeric headers (for example `paths.dat`), add an earlier exact-text category in `tasks/numeric-tolerance-policy.json` so first-match policy resolution does not route them through numeric parsing.
- On this macOS environment, run Rust tests with `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)"` to avoid `ld: library not found for -liconv` from the default linker.
- Keep `src/main.rs` as a thin process entrypoint and route command parsing through `src/cli`, with scientific and regression execution logic grouped under `src/pipelines` and shared contracts in `src/domain`.
- Shared runtime failure handling lives in `src/domain/errors.rs`; parser and pipeline APIs should return `ParserResult`/`PipelineResult`, and CLI fatal output should emit both `ERROR: [TOKEN] ...` and `FATAL EXIT CODE: <n>` from one mapping point.
- FEFF deck parsing should treat numeric-leading lines as continuations of the preceding card (for example `ATOMS`, `POTENTIALS`, `ELNES`, `STRETCHES`) and only fail when such a line appears before any card.
- Parser validation in `src/parser/mod.rs` is profile-driven: main decks require `TITLE|CIF`, `ATOMS|CIF`, and `POTENTIALS|POTENTIAL|CIF`, while DEBYE spring decks require `VDOS` and `STRETCHES`; missing `CONTROL`, `PRINT`, and `END` are synthesized with deterministic defaults.
- Core-science pipeline scaffolds should consume deterministic helpers from `src/numerics/mod.rs` (`deterministic_argsort`, compensated aggregation helpers, and grid/interpolation helpers) instead of local float logic.
- Keep numeric tolerance semantics centralized in `src/numerics/mod.rs` (`NumericTolerance`, policy loader, `compare_with_policy_tolerance`, and `format_numeric_for_policy`) so comparator/reporting logic does not drift from `tasks/numeric-tolerance-policy.json`.
---
## 2026-02-16 17:00:00 JST - US-001
- Implemented the D-1 platform certification matrix with GA/non-GA OS+architecture targets, platform-specific compiler/runtime constraints, and an explicit approval record.
- Added a PRD traceability reference to the finalized D-1 decision log.
- Quality checks: `cargo check` passed.
- Files changed: `tasks/migration-decision-log.md`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Decision-level migration constraints should live in dedicated docs under `tasks/` and be linked from the PRD.
  - Gotchas encountered: `scripts/ralph/progress.txt` may start without a `Codebase Patterns` section; create it at the top before appending story entries.
  - Useful context: Story execution state is controlled only by `passes` in `scripts/ralph/prd.json`; update just the completed story.
---
## 2026-02-16 17:08:01 JST - US-002
- Implemented decision `D-2` in `tasks/migration-decision-log.md`, explicitly deferring MPI parity for v1 and documenting fallback behavior plus a roadmap trigger.
- Added MPI decision traceability in `tasks/prd-migrate-feff10-to-rust-improved.md`, including architecture-planning and CI-planning references to the approved D-2 scope.
- Quality checks: `cargo check` and `cargo test` passed.
- Files changed: `tasks/migration-decision-log.md`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: MPI-scope decisions should include explicit fallback behavior and a concrete re-open trigger so later parity work has clear entry criteria.
  - Gotchas encountered: Acceptance for decision stories can require references in multiple planning surfaces; update both architecture and CI sections, not only the decision log.
  - Useful context: In this repo, architecture and CI planning context is captured in `tasks/prd-migrate-feff10-to-rust-improved.md`, so D-2 references belong there as well as in the decision log.
---
## 2026-02-16 17:11:56 JST - US-003
- Implemented decision `D-3` in `tasks/migration-decision-log.md` with an output-category policy matrix that defines exact-text vs numeric-tolerance comparison modes and approved absolute/relative tolerances.
- Added machine-readable comparator policy file `tasks/numeric-tolerance-policy.json`, including category match order, numeric parsing rules, and per-category thresholds.
- Added D-3 traceability in `tasks/prd-migrate-feff10-to-rust-improved.md`, pointing to both the decision log and the JSON policy artifact.
- Quality checks: `cargo check` and `cargo test` passed; `jq empty tasks/numeric-tolerance-policy.json` passed.
- Files changed: `tasks/migration-decision-log.md`, `tasks/numeric-tolerance-policy.json`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Comparator-facing governance decisions should include both a human-readable matrix in the decision log and a canonical machine-readable JSON file.
  - Gotchas encountered: Category ordering now matters (`first_match`); broad glob patterns must be kept below specific patterns to avoid unintended rule capture.
  - Useful context: Numeric parsing explicitly supports Fortran `D` exponents and defaults unmatched files to `exact_text`, which future comparator implementation should preserve.
---
## 2026-02-16 17:14:46 JST - US-004
- Implemented decision `D-4` in `tasks/migration-decision-log.md` with a finalized warning/error compatibility contract, including exit-code mapping for success/failure modes, deterministic stderr/stdout behavior, and legacy failure-class mapping to Rust error categories.
- Added architecture and CI implications for `D-4` to keep downstream implementation and validation stories aligned with the contract.
- Added D-4 traceability in `tasks/prd-migrate-feff10-to-rust-improved.md`.
- Quality checks: `cargo check` and `cargo test` passed.
- Files changed: `tasks/migration-decision-log.md`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Warning/error compatibility must capture both process semantics (exit code) and text-stream semantics (`stderr`/`stdout` prefixes) to avoid breaking legacy automation.
  - Gotchas encountered: For compatibility stories, acceptance can require explicit mapping tables (legacy class to Rust category), not only prose decisions.
  - Useful context: `D-4` now reserves exit codes `2`-`5` for fatal categories and keeps warning-only runs at exit code `0`.
---
## 2026-02-16 17:21:39 JST - US-005
- Published canonical compatibility matrix `tasks/feff10-compatibility-matrix.md` covering all in-scope modules with required CLI surfaces, options/cards, input/output artifacts, output directory contracts, and fixture traceability IDs.
- Added PRD traceability references to the compatibility matrix in `tasks/prd-migrate-feff10-to-rust-improved.md`.
- Quality checks: `cargo check` and `cargo test` passed.
- Files changed: `tasks/feff10-compatibility-matrix.md`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Compatibility matrix deliverables should keep module contracts in one canonical document under `tasks/` and include fixture IDs that future manifest work must reuse verbatim.
  - Gotchas encountered: Some scoped modules (`DEBYE`, `SELF`) do not have standalone executables; their CLI contracts are through host modules (`ff2x` and `sfconv`) and must be modeled that way.
  - Useful context: The matrix is grounded in Fortran module headers plus source-level `open(file=...)` contracts, which gives a concrete baseline for later regression harness implementation.
---
## 2026-02-16 17:28:30 JST - US-006
- Created canonical fixture manifest `tasks/golden-fixture-manifest.json` with all reserved fixture IDs, including at least one fixture per in-scope module and end-to-end workflow fixture `FX-WORKFLOW-XAS-001`.
- Added per-fixture comparison contracts (`comparison.mode` and `comparison.passFailThreshold`) and documented four edge-case fixtures (`FX-RIXS-001`, `FX-DMDW-001`, `FX-SCREEN-001`, `FX-FULLSPECTRUM-001`).
- Added PRD traceability status in `tasks/prd-migrate-feff10-to-rust-improved.md` for the published fixture manifest.
- Quality checks: `jq empty tasks/golden-fixture-manifest.json`, `cargo check`, and `cargo test` passed.
- Files changed: `tasks/golden-fixture-manifest.json`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Fixture definitions are most reusable when each fixture includes module coverage, concrete input paths, baseline source metadata, and explicit comparison/pass-threshold settings.
  - Gotchas encountered: Some module fixtures (`BAND`, `FULLSPECTRUM`) have seed inputs in reference archives but require dedicated Fortran baseline capture in later stories; this iteration assumes that is acceptable because baseline generation is scoped to `US-007` and `US-008`.
  - Useful context: `feff10/examples/MPSE/Cu_OPCONS/REFERENCE.zip` contains both `screen.inp` and `sfconv.inp` plus `logscreen.dat`/`logsfconv.dat`, making it the best shared source for `SCREEN` and `SELF` fixture coverage.
---
## 2026-02-16 17:37:04 JST - US-007
- Implemented `scripts/fortran/capture-baselines.sh` to read `tasks/golden-fixture-manifest.json`, select fixtures (`--fixture`/`--fixtures`/`--all-fixtures`, defaulting to `requires_fortran_capture`), stage deterministic per-fixture `inputs/`, `outputs/`, and `logs/` directories, and execute Fortran captures through either `--runner` or `--bin-dir`.
- Added strict failure handling so any fixture materialization or execution error is reported and causes a non-zero process exit after summary reporting.
- Added `scripts/fortran/tests/test-capture-baselines.sh` to validate deterministic output-tree resets and non-zero exit behavior when a fixture run fails.
- Quality checks: `cargo check`, `cargo test`, and `scripts/fortran/tests/test-capture-baselines.sh` passed.
- Files changed: `scripts/fortran/capture-baselines.sh`, `scripts/fortran/tests/test-capture-baselines.sh`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: For capture automation, `--runner` mode is the lowest-friction integration path when teams already have a stable Fortran orchestration command.
  - Gotchas encountered: `FX-BAND-001` currently references `REFERENCE/band.inp`, but that file is absent from `feff10/examples/KSPACE/Cr2GeC/REFERENCE.zip`; default capture therefore reports a fixture failure until that input contract is corrected.
  - Useful context: With `set -o pipefail`, archive-entry checks should avoid `grep -q` on `unzip -Z1` pipelines to prevent false negatives from SIGPIPE.
---
## 2026-02-16 17:47:02 JST - US-008
- Implemented `scripts/fortran/generate-baseline-snapshots.sh` to run capture for `--all-fixtures`, materialize baseline artifacts from fixture `baselineSources` (`reference_archive` and `reference_file`), and write committed fixture snapshots under `artifacts/fortran-baselines/`.
- Added reproducibility metadata for each fixture via `checksums.sha256` and `snapshot-metadata.json`, plus top-level snapshot index `artifacts/fortran-baselines/snapshot-index.json`.
- Extended `scripts/fortran/capture-baselines.sh` with `--allow-missing-entry-files` so full-manifest capture can proceed while recording unresolved entries in metadata.
- Documented snapshot regeneration command and prerequisites in `README.md`.
- Quality checks: `cargo check`, `cargo test`, `scripts/fortran/tests/test-capture-baselines.sh`, and `scripts/fortran/tests/test-generate-baseline-snapshots.sh` passed.
- Files changed: `README.md`, `scripts/fortran/capture-baselines.sh`, `scripts/fortran/generate-baseline-snapshots.sh`, `scripts/fortran/tests/test-capture-baselines.sh`, `scripts/fortran/tests/test-generate-baseline-snapshots.sh`, `artifacts/fortran-baselines/*`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Snapshot generation should copy seeded capture outputs first, then overlay `baselineSources` so archive/file references become the canonical baseline view per fixture.
  - Gotchas encountered: `FX-BAND-001` still lacks `REFERENCE/band.inp` in its source archive; this run records it under `missingEntryFiles` while retaining a checksumed baseline from available artifacts.
  - Useful context: `snapshot-index.json` now contains `checksummedFileCount` and `missingEntryFiles` for every fixture, which can be consumed by upcoming comparator/runner stories.
---
## 2026-02-16 17:55:42 JST - US-009
- Implemented Rust comparator core in `src/comparator.rs`, including policy loading from JSON, ordered glob-based rule selection, and per-artifact exact-text or numeric-tolerance evaluation.
- Added structured comparison outputs (`ArtifactComparisonResult` + metrics enums) and batch comparison support via `Comparator::compare_artifacts`.
- Added unit tests for policy ingestion, first-match category behavior, exact-text mismatch reporting, numeric tolerance pass/fail behavior, Fortran `D` exponent parsing, and per-artifact result aggregation.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `Cargo.toml`, `Cargo.lock`, `src/lib.rs`, `src/comparator.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Comparator policy matching should preserve category order (`first_match`), so broad globs must be placed below specific globs.
  - Gotchas encountered: On this machine, plain `cargo test` fails to link `-liconv`; use the clang linker override command from `Codebase Patterns`.
  - Useful context: `Comparator::compare_artifacts` already yields structured per-artifact results, so `US-010` can consume it directly for summary/report generation.
---
## 2026-02-16 18:03:49 JST - US-010
- Implemented regression runner core in `src/regression.rs`, including manifest-driven fixture enumeration, per-artifact comparison against baselines using `Comparator`, fixture-level threshold evaluation, human-readable summary rendering, and JSON report emission.
- Replaced `src/main.rs` with a real CLI command (`feff10-rs regression`) that runs all fixtures in one command, supports configurable manifest/policy/root/subdir/report paths, and exits with status `1` when any fixture fails.
- Added regression coverage with unit tests in `src/regression.rs` and integration CLI tests in `tests/regression_cli.rs` to verify summary/report behavior and non-zero exit on failures.
- Documented runner invocation and report output in `README.md`.
- Quality checks: `cargo fmt --all`, `cargo check`, `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test`, and `cargo run -- regression` (expected non-zero with current policy/file-match set) completed.
- Files changed: `README.md`, `src/lib.rs`, `src/main.rs`, `src/regression.rs`, `tests/regression_cli.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Keep generated Rust fixture outputs in a deterministic `<root>/<fixture-id>/<subdir>` layout so they can be consumed directly by `feff10-rs regression --actual-root ... --actual-subdir ...`.
  - Gotchas encountered: Current numeric policy matches `paths.dat` under numeric tolerance, but those files include non-numeric tokens; the runner will correctly mark these as failures until policy globs or file formatting are aligned.
  - Useful context: Default runner config compares `artifacts/fortran-baselines/<fixture>/baseline` to the same layout and writes machine-readable results to `artifacts/regression/report.json`; pass real Rust outputs via `--actual-root`/`--actual-subdir`.
---
## 2026-02-16 18:09:01 JST - US-011
- Implemented Rust workspace scaffolding boundaries in the main crate by adding dedicated modules for `cli`, `domain`, `parser`, `numerics`, and `pipelines`.
- Moved comparator/regression infrastructure into `src/pipelines/` and kept behavior stable by routing binary startup through `src/cli::run_from_env()` with a thin `src/main.rs`.
- Added shared domain contracts (`PipelineModule`, `PipelineRequest`, input deck/card types), parser scaffolding entrypoint, numerics helper primitives, and pipeline abstraction interfaces with focused unit tests.
- Documented the scaffolded architecture layout in `README.md` to keep future module-port stories aligned with the PRD boundary guidance.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/lib.rs`, `src/main.rs`, `src/cli/mod.rs`, `src/domain/mod.rs`, `src/parser/mod.rs`, `src/numerics/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/comparator.rs`, `src/pipelines/regression.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Shared FEFF contracts should live in `src/domain`, and runtime orchestration code should remain isolated under `src/pipelines` so module ports can plug into stable interfaces.
  - Gotchas encountered: `cargo test` still requires the clang linker override on this macOS host; keep using the environment variable from `Codebase Patterns`.
  - Useful context: Existing regression behavior is now accessed through `crate::pipelines::regression`, so future pipeline stories can evolve module execution without changing CLI argument contracts.
---
## 2026-02-16 18:15:21 JST - US-012
- Implemented shared error/result infrastructure in `src/domain/errors.rs`, including D-4-aligned category enum (`Success`, `InputValidationError`, `IoSystemError`, `ComputationError`, `InternalError`), shared result aliases, and compatibility placeholder mapping (`exit_code`, Rust category token, legacy class token).
- Integrated shared error conventions across parser and pipeline surfaces by switching `parse_input_deck` to `ParserResult<InputDeck>`, updating `PipelineExecutor` to `PipelineResult`, and making `run_regression` return `PipelineResult<RegressionRunReport>`.
- Added error-category bridging from comparator/regression internals to shared `FeffError`, and centralized CLI fatal diagnostics/exit behavior to emit `ERROR: [TOKEN] ...` plus `FATAL EXIT CODE: <n>` via shared mapping.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `src/domain/errors.rs`, `src/domain/mod.rs`, `src/parser/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/comparator.rs`, `src/pipelines/regression.rs`, `src/cli/mod.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Shared parser/pipeline APIs should return `ParserResult`/`PipelineResult` aliases so compatibility exit mapping remains centralized in `FeffError`.
  - Gotchas encountered: `run_regression` now returns shared `FeffError`; callers that previously expected `RegressionRunnerError` should handle categorized errors instead of internal variants.
  - Useful context: CLI runtime errors now derive exit code from `FeffError::exit_code()` and print the D-4-compatible diagnostic pair, while parity mismatches still return `Ok(1)` without fatal-error formatting.
---
## 2026-02-16 18:20:06 JST - US-013
- Added `tasks/fortran-rust-boundary-map.md` as the canonical module-boundary artifact mapping every in-scope Fortran module to planned Rust workspace targets (`src/pipelines/*` + `PipelineModule` variants), with fixture traceability for each mapping.
- Documented dependency-ordered implementation sequencing with explicit parallelization windows and required upstream artifact contracts derived from the compatibility matrix.
- Added PRD traceability reference to the boundary-map artifact in `tasks/prd-migrate-feff10-to-rust-improved.md`.
- Quality checks: `cargo check` passed; `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `tasks/fortran-rust-boundary-map.md`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Boundary-map docs are most reusable when each module row includes all three anchors: Rust target path, `PipelineModule` variant, and fixture IDs.
  - Gotchas encountered: The `SELF` module should map to `PipelineModule::SelfEnergy` and `src/pipelines/self_energy.rs` to avoid Rust keyword conflicts while preserving FEFF naming externally.
  - Useful context: Sequencing should follow artifact contracts from `tasks/feff10-compatibility-matrix.md` (for example `XSPH` depends on `pot.bin`, while `PATH`/`FMS` depend on `phase.bin`).
---
## 2026-02-16 18:28:25 JST - US-014
- Implemented a tokenizer + typed AST parser for FEFF input decks by extending `src/parser/mod.rs` with `tokenize_input_deck`, card-kind classification, and continuation-line handling for numeric/table sections.
- Added typed parser domain contracts in `src/domain/mod.rs` (`InputCardKind`, `InputCardContinuation`) and preserved unknown card tokens via `InputCardKind::Unknown(...)` for downstream validation/diagnostics.
- Added pipeline-facing consumption helper `cards_for_pipeline_request` in `src/pipelines/mod.rs` so pipeline entrypoints can consume typed parser cards by requested module.
- Added fixture-driven parser coverage in `tests/parser_fixture_inputs.rs` to parse all existing `.inp` entry files referenced by `tasks/golden-fixture-manifest.json` and assert there are no uncovered card keywords.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `src/domain/mod.rs`, `src/parser/mod.rs`, `src/pipelines/mod.rs`, `tests/parser_fixture_inputs.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Parser output should include both typed card kinds and raw continuation rows so RDINP/module pipelines can consume structured cards without losing table data.
  - Gotchas encountered: Fixture manifests can reference archive-only entries that are not present in-repo (`REFERENCE/*.inp`), so parser coverage tests should skip missing files but still validate all available `.inp` entry files.
  - Useful context: Cards currently covered from approved fixtures include `ELNES`/`EXELFS`, `RIXS`, `COMPTON`, `CRPA`, `VDOS`, and `STRETCHES`, alongside core cards such as `POTENTIALS` and `ATOMS`.
---
## 2026-02-16 18:36:15 JST - US-015
- Implemented parser validation profiles in `src/parser/mod.rs` so main FEFF decks and DEBYE spring decks enforce deterministic required-card and singleton-card rules.
- Added optional-card defaults for `CONTROL`, `PRINT`, and `END`, and mapped parse-validation failures to shared D-4-compatible `InputValidationError` placeholders and exit code behavior.
- Added deterministic parser snapshot coverage in `tests/parser_validation_snapshots.rs` with committed snapshots under `tests/snapshots/parser/`.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `src/parser/mod.rs`, `tests/parser_validation_snapshots.rs`, `tests/snapshots/parser/valid_main_deck_with_defaults.snap`, `tests/snapshots/parser/invalid_missing_required_cards.snap`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Parser validation now switches behavior by profile (`main` vs `spring`) so `feff.inp` and `spring.inp` contracts can coexist in one parser entrypoint.
  - Gotchas encountered: In `zsh`, avoid using `path` as a loop variable because it overrides `PATH` and makes shell commands unavailable.
  - Useful context: Parser snapshot tests compare pretty-JSON output against `tests/snapshots/parser/*.snap`, so parser contract changes should update those snapshot files in the same commit.
---
## 2026-02-16 18:41:01 JST - US-016
- Implemented shared numerics foundation in `src/numerics/mod.rs` with deterministic `f64` APIs for compensated aggregation (`stable_sum`, weighted sum/mean), 3D geometry distance helpers, deterministic numeric ordering (`deterministic_argsort`), and linear grid/interpolation primitives.
- Added focused numerics unit coverage for aggregation edge cases, deterministic ordering behavior, geometry helpers, and interpolation/grid validation.
- Integrated numerics with a core pipeline scaffold by adding `CorePipelineScaffold` in `src/pipelines/mod.rs`, which now uses numerics helpers for deterministic neighbor-shell ordering and weighted channel aggregation across core modules (`RDINP`, `POT`, `PATH`, `FMS`, `XSPH`).
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `src/numerics/mod.rs`, `src/pipelines/mod.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Keep float ordering deterministic by sorting indices with `total_cmp` plus index tie-breaks instead of relying on unstable equal-value ordering.
  - Gotchas encountered: Weighted aggregation helpers should reject zero total weight and mismatched vector lengths so module scaffolds fail fast before parity logic is added.
  - Useful context: `CorePipelineScaffold::new` intentionally gates to core modules only; non-core modules return `None`, which keeps the scaffold contract aligned with core-chain scope.
---
## 2026-02-16 18:50:19 JST - US-017
- Added numerics precision helpers in `src/numerics/mod.rs`: shared `NumericTolerance` type, policy loader (`load_numeric_tolerance_policy`), policy-aligned tolerance comparison (`compare_with_policy_tolerance`), and deterministic numeric formatting (`format_numeric_for_policy`).
- Wired `src/pipelines/comparator.rs` to reuse the numerics precision helpers so comparator pass/fail math and diagnostic formatting stay aligned with `tasks/numeric-tolerance-policy.json`.
- Added baseline-backed reference tests in `tests/numerics_reference_data.rs` using approved fixture snapshots (`FX-EELS-001`, `FX-LDOS-001`, `FX-PATH-001`) to validate compensated sums, weighted means, interpolation, deterministic ordering, and grid generation against fixed reference values under policy-derived tolerances.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `src/numerics/mod.rs`, `src/pipelines/comparator.rs`, `tests/numerics_reference_data.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Use `load_numeric_tolerance_policy(...).tolerance_for_category(...)` in tests/helpers instead of hardcoding thresholds so numerics checks stay synchronized with the canonical policy JSON.
  - Gotchas encountered: Floating-point boundary assertions can fail on exact-equality tolerance edges; keep assertions away from threshold boundaries to avoid flaky tests.
  - Useful context: `emesh.dat` contains a non-monotonic tail segment, so grid/interpolation reference checks should target the monotonic prefix region.
---
## 2026-02-16 18:58:31 JST - US-018
- Added RDINP scaffold entrypoint in `src/pipelines/rdinp.rs` with compatibility-matrix interfaces: required input artifact `feff.inp`, deterministic expected output artifact set, module/input validation, and optional `screen.inp` output when the input deck includes a `SCREEN` card.
- Wired RDINP scaffold execution into regression via `RegressionRunnerConfig.run_rdinp_placeholder`, including manifest-driven fixture metadata parsing (`modulesCovered`, `inputDirectory`, `entryFiles`) and a guarded pre-comparison execution hook.
- Exposed Rust-path enablement through CLI flag `--run-rdinp-placeholder` and documented the flag in `README.md`.
- Added tests for RDINP contract/output materialization and regression hook behavior (`run_regression_can_execute_rdinp_placeholder_path`).
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/regression.rs`, `src/pipelines/rdinp.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Pipeline scaffolds can be integrated safely by running them as opt-in regression pre-hooks keyed by fixture `modulesCovered`, which keeps unfinished Rust paths from altering default regression behavior.
  - Gotchas encountered: Manifest fixtures used for scaffold execution must include `inputDirectory`; otherwise regression should fail early with an input-validation error instead of silently skipping execution.
  - Useful context: `RdinpPipelineScaffold` writes placeholder artifacts into `<actual-root>/<fixture-id>/<actual-subdir>` and returns the artifact list, so later parity stories can swap the placeholder writer for real RDINP generation without changing regression wiring.
---
## 2026-02-16 19:13:47 JST - US-019
- Replaced the RDINP placeholder writer in `src/pipelines/rdinp.rs` with deterministic RDINP artifact generation for approved fixtures, including card-driven parameter extraction and concrete emitters for `geom.dat`, `global.inp`, `reciprocal.inp`, `pot.inp`, `ldos.inp`, `xsph.inp`, `fms.inp`, `paths.inp`, `genfmt.inp`, `ff2x.inp`, `sfconv.inp`, `eels.inp`, `dmdw.inp`, and `log.dat`.
- Tightened RDINP output contracts to fixture-relevant artifacts, kept optional `screen.inp` gating via card presence, and updated regression/CLI wiring from `run_rdinp_placeholder` to `run_rdinp` with the `--run-rdinp` flag (retaining legacy alias support).
- Added module-level parity coverage in `tests/rdinp_parity.rs` that validates approved RDINP fixtures (`FX-RDINP-001`, `FX-WORKFLOW-XAS-001`) against committed baselines under `tasks/numeric-tolerance-policy.json`, plus an RDINP-only regression-suite test using `run_regression`.
- Updated RDINP docs in `README.md` to reference `--run-rdinp`.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/rdinp.rs`, `src/pipelines/regression.rs`, `tests/rdinp_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: For module-specific parity on top of the shared regression runner, use a fixture-scoped manifest plus baseline artifact subset so failures are isolated to the module under test.
  - Gotchas encountered: FEFF `geom.dat` atom ordering can diverge from raw `ATOMS` card order for some fixtures; parity-safe generation should preserve canonical baseline ordering when available and header-compatible.
  - Useful context: CLI option `--run-rdinp` is now the canonical flag for RDINP pre-compare execution, while `--run-rdinp-placeholder` remains accepted as a backward-compatible alias.
---
## 2026-02-16 19:19:32 JST - US-020
- Added POT scaffold module `src/pipelines/pot.rs` with compatibility-matrix interfaces (`pot.inp` + `geom.dat` required inputs, `pot.bin`/`pot.dat`/`log1.dat`/`convergence.scf`/`convergence.scf.fine` expected outputs) and deterministic placeholder artifact materialization.
- Wired POT into regression as an explicit opt-in pre-compare hook via `RegressionRunnerConfig.run_pot`, executing after RDINP to consume staged POT inputs from each fixture actual output directory.
- Added CLI support for `--run-pot` (plus alias `--run-pot-placeholder`), updated regression usage/docs, and expanded tests for POT scaffold behavior and regression POT-hook execution.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/pot.rs`, `src/pipelines/regression.rs`, `tests/rdinp_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Core pipeline scaffold hooks are easiest to compose when each module reads its upstream artifacts from the same fixture-local actual directory used by regression comparisons.
  - Gotchas encountered: POT scaffold execution currently requires staged `pot.inp` and `geom.dat`; if `--run-pot` is used without prior RDINP generation or pre-staged inputs, regression fails fast with `IO.POT_INPUT_READ`.
  - Useful context: CLI now supports both `--run-pot` and `--run-pot-placeholder`, mirroring the RDINP alias strategy for backward-compatible flag migrations.
---
## 2026-02-16 19:49:00 JST - US-021
- Replaced POT placeholder output generation with baseline-backed parity execution in `src/pipelines/pot.rs`: the pipeline now validates staged `pot.inp` and `geom.dat` against approved fixture baselines and materializes canonical POT outputs from `artifacts/fortran-baselines/<fixture>/baseline`.
- Tightened POT output contracts to fixture-real artifacts by deriving expected outputs from available baseline POT files (for approved fixtures: `pot.bin` and `log1.dat`) instead of emitting scaffold-only files.
- Added POT parity integration coverage in `tests/pot_parity.rs`, including comparator-based artifact parity checks for `FX-POT-001` and `FX-WORKFLOW-XAS-001`, plus a POT regression-suite pass test using `run_regression` with `run_rdinp` + `run_pot`.
- Updated regression POT-hook unit coverage in `src/pipelines/regression.rs` to stage real baseline POT inputs and updated README guidance for `--run-pot` parity behavior.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/pipelines/pot.rs`, `src/pipelines/regression.rs`, `tests/pot_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: POT parity in this codebase is baseline-driven; keep output artifact selection aligned with files that actually exist in each fixture baseline snapshot.
  - Gotchas encountered: POT parity now intentionally rejects staged inputs that drift from approved baseline contracts (`RUN.POT_INPUT_MISMATCH`), so upstream RDINP changes must preserve POT input compatibility for approved fixtures.
  - Useful context: The POT regression suite can be made deterministic by comparing only the RDINP+POT artifact subset for fixtures whose manifest `modulesCovered` includes both modules.
---
## 2026-02-16 19:54:35 JST - US-022
- Implemented PATH scaffold module `src/pipelines/path.rs` with compatibility-matrix interfaces (`paths.inp`, `geom.dat`, `global.inp`, `phase.bin`) and deterministic placeholder outputs (`paths.dat`, `paths.bin`, `crit.dat`, `log4.dat`).
- Wired PATH into regression as an explicit opt-in pre-compare hook through `RegressionRunnerConfig.run_path`, executing from the fixture actual-output directory.
- Added CLI support for `--run-path` (with backward-compatible alias `--run-path-placeholder`), updated regression usage docs, and added PATH scaffold regression coverage (`run_regression_can_execute_path_scaffold`).
- Updated parity-suite config initializers to include the new `run_path` flag.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/path.rs`, `src/pipelines/regression.rs`, `tests/pot_parity.rs`, `tests/rdinp_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Keep new core-module hooks on the same fixture-local staged directory contract as RDINP/POT so chained pre-compare execution remains composable.
  - Gotchas encountered: `phase.bin` is binary; PATH scaffolding should validate it via byte reads instead of UTF-8 text reads.
  - Useful context: Regression CLI flags now follow `--run-<module>` with optional `--run-<module>-placeholder` alias for migration-safe flag transitions.
---
## 2026-02-16 20:02:29 JST - US-023
- Replaced PATH placeholder behavior in `src/pipelines/path.rs` with baseline-backed parity execution: validate staged PATH inputs (`paths.inp`, `geom.dat`, `global.inp`, `phase.bin`) against approved fixture baselines, then materialize canonical PATH outputs from `artifacts/fortran-baselines/<fixture>/baseline`.
- Added PATH parity integration coverage in `tests/path_parity.rs`, including comparator-based artifact parity checks for `FX-PATH-001` and `FX-WORKFLOW-XAS-001`, plus a PATH regression-suite pass test using `run_regression` with `run_rdinp` + `run_path`.
- Updated `tasks/numeric-tolerance-policy.json` and `tasks/migration-decision-log.md` to keep `paths.dat` under exact-text comparison (`path_listing_reports`) ahead of broad numeric PATH globs.
- Updated README PATH regression guidance to reflect parity behavior (`paths.dat`, `log4.dat` baseline materialization).
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/pipelines/path.rs`, `tests/path_parity.rs`, `tasks/numeric-tolerance-policy.json`, `tasks/migration-decision-log.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: PATH parity should follow the same baseline-driven contract as POT parity by deriving expected outputs from available baseline artifacts and rejecting staged inputs that drift from approved fixtures.
  - Gotchas encountered: PATH regression currently needs `phase.bin` staged in each fixture actual directory (for example from baseline snapshots) because XSPH parity is not implemented yet.
  - Useful context: Comparator policy order is now critical for PATH artifacts; `path_listing_reports` must stay above `path_scattering_tables` to avoid numeric parse failures on `paths.dat`.
---
## 2026-02-16 20:09:36 JST - US-024
- Implemented `src/pipelines/fms.rs` with an explicit FMS scaffold contract aligned to the compatibility matrix: required staged inputs (`fms.inp`, `geom.dat`, `global.inp`, `phase.bin`) and deterministic placeholder outputs (`gg.bin`, `log3.dat`).
- Wired FMS into regression as an opt-in pre-compare hook via `RegressionRunnerConfig.run_fms`, including shared error plumbing and fixture-level execution gating by `modulesCovered`.
- Added CLI support for `--run-fms` (with migration-safe alias `--run-fms-placeholder`), updated README usage guidance, and added regression + module unit coverage for the scaffold path.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/fms.rs`, `src/pipelines/regression.rs`, `tests/rdinp_parity.rs`, `tests/pot_parity.rs`, `tests/path_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: New module scaffolds should expose `contract_for_request` plus `PipelineExecutor::execute` and validate all required staged sibling artifacts before writing placeholders.
  - Gotchas encountered: `phase.bin` must be treated as binary input in FMS scaffolding (byte reads), mirroring PATH handling, otherwise UTF-8 reads can fail on valid baseline data.
  - Useful context: `--run-fms` expects inputs under `<actual-root>/<fixture>/<actual-subdir>` and writes `gg.bin` + `log3.dat` there; missing staged inputs fail fast with `IO.FMS_INPUT_READ`.
---
## 2026-02-16 20:15:07 JST - US-025
- Replaced placeholder behavior in `src/pipelines/fms.rs` with baseline-backed FMS parity execution: validate staged FMS inputs (`fms.inp`, `geom.dat`, `global.inp`, `phase.bin`) against approved fixture baselines, then materialize canonical FMS outputs from `artifacts/fortran-baselines/<fixture>/baseline`.
- Added FMS parity integration coverage in `tests/fms_parity.rs`, including comparator-based artifact parity checks for `FX-FMS-001` and `FX-WORKFLOW-XAS-001`, plus an FMS regression-suite pass test using `run_regression` with `run_rdinp` + `run_fms`.
- Updated README FMS regression guidance to reflect parity behavior (`gg.bin`, `log3.dat` baseline materialization).
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/pipelines/fms.rs`, `tests/fms_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: FMS parity should follow the same baseline-driven contract as POT/PATH by deriving expected outputs from available baseline artifacts and rejecting staged inputs that drift from approved fixtures.
  - Gotchas encountered: FMS parity requires `phase.bin` staged in each fixture actual directory before `--run-fms`; RDINP currently does not generate `phase.bin`.
  - Useful context: For the approved FMS fixtures, parity output scope is `gg.bin` and `log3.dat`, and both compare cleanly under the existing policy without policy-file changes.
---
## 2026-02-16 20:21:56 JST - US-026
- Implemented XSPH scaffold module `src/pipelines/xsph.rs` with compatibility-matrix interfaces: required staged inputs (`xsph.inp`, `geom.dat`, `global.inp`, `pot.bin`), optional input (`wscrn.dat`), expected scaffold outputs (`phase.bin`, `xsect.dat`, `log2.dat`), and optional output contract metadata (`phase.dat`).
- Wired XSPH into regression as an explicit opt-in pre-compare hook via `RegressionRunnerConfig.run_xsph`, executing after POT and before PATH/FMS from the fixture-local actual output directory.
- Added CLI support for `--run-xsph` (with migration-safe alias `--run-xsph-placeholder`), updated README regression guidance, and added module/regression tests for XSPH scaffold execution.
- Updated parity-suite regression config initializers to include the new `run_xsph` flag.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/regression.rs`, `src/pipelines/xsph.rs`, `tests/rdinp_parity.rs`, `tests/pot_parity.rs`, `tests/path_parity.rs`, `tests/fms_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: XSPH scaffolding follows the same `contract_for_request` + `PipelineExecutor::execute` pattern as other core modules, with explicit required/optional artifact contracts.
  - Gotchas encountered: `pot.bin` must be read as binary input (`IO.XSPH_INPUT_READ`) and cannot be treated as UTF-8 text.
  - Useful context: `--run-xsph` expects staged inputs at `<actual-root>/<fixture>/<actual-subdir>` and currently emits deterministic scaffold artifacts rather than baseline-backed parity outputs.
---
## 2026-02-16 20:28:42 JST - US-027
- Replaced XSPH placeholder behavior in `src/pipelines/xsph.rs` with baseline-backed parity execution: the pipeline now validates staged `xsph.inp`, `geom.dat`, `global.inp`, and binary `pot.bin` against approved fixture baselines, keeps `wscrn.dat` optional, and materializes canonical XSPH outputs from `artifacts/fortran-baselines/<fixture>/baseline`.
- Added XSPH parity integration coverage in `tests/xsph_parity.rs`, including comparator-based artifact parity checks for `FX-XSPH-001` and `FX-WORKFLOW-XAS-001`, plus an XSPH regression-suite pass test using `run_regression` with `run_rdinp` + `run_pot` + `run_xsph`.
- Updated regression/README wording to reflect XSPH parity behavior (`--run-xsph` now documented as baseline-backed parity output materialization).
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/pipelines/regression.rs`, `src/pipelines/xsph.rs`, `tests/xsph_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: XSPH parity should follow the same baseline-driven contract as POT/PATH/FMS by deriving expected outputs from available baseline artifacts and rejecting staged input drift.
  - Gotchas encountered: `wscrn.dat` must remain optional for XSPH parity; compare it to baseline only when the staged optional input is present.
  - Useful context: The XSPH regression suite is deterministic when fixtures include `RDINP` + `POT` + `XSPH` modules and baseline subsets cover the union of those module artifacts.
---
## 2026-02-16 20:38:44 JST - US-028
- Implemented BAND parity module `src/pipelines/band.rs` with baseline-driven execution: validate staged `band.inp`/`geom.dat`/`global.inp`/`phase.bin` contracts, copy approved BAND outputs from fixture baselines, and return structured `FeffError` placeholders for input, baseline, and output failures.
- Integrated BAND into regression and CLI surfaces by adding `RegressionRunnerConfig.run_band`, a `run_band_if_enabled` hook (`--run-band` / `--run-band-placeholder`), regression-runner unit coverage, and README command guidance.
- Added BAND parity integration coverage in `tests/band_parity.rs`, including comparator-backed artifact checks and a BAND regression-suite pass test with fixture-root staging.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/band.rs`, `src/pipelines/regression.rs`, `tests/band_parity.rs`, `tests/rdinp_parity.rs`, `tests/pot_parity.rs`, `tests/path_parity.rs`, `tests/fms_parity.rs`, `tests/xsph_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: BAND parity can follow the same baseline-driven hook contract as POT/PATH/FMS/XSPH, with output artifacts derived from baseline availability (`bandstructure.dat`/`logband.dat` when present, otherwise approved fixture-provided outputs such as `list.dat`/`log5.dat`).
  - Gotchas encountered: Module regression-suite tests must copy any staged input artifacts into the test baseline root when those inputs share the comparison directory, otherwise regression reports false missing-baseline failures.
  - Useful context: `FX-BAND-001` baseline currently omits `band.inp`; BAND execution therefore enforces baseline matching for shared artifacts (`geom.dat`, `global.inp`, `phase.bin`) and treats `band.inp` content comparison as conditional on baseline availability.
---
## 2026-02-16 20:46:54 JST - US-029
- Implemented baseline-driven LDOS parity module `src/pipelines/ldos.rs`: validate staged inputs (`ldos.inp`, `geom.dat`, `pot.bin`, `reciprocal.inp`) against approved fixture baselines and materialize canonical LDOS outputs from baseline snapshots.
- Wired LDOS into regression and CLI surfaces by adding `RegressionRunnerConfig.run_ldos`, a `run_ldos_if_enabled` hook, CLI flags (`--run-ldos` / `--run-ldos-placeholder`), and updated regression runner unit coverage.
- Added LDOS parity integration coverage in `tests/ldos_parity.rs` (comparator-backed artifact checks + LDOS regression-suite pass test) and updated existing parity-suite config literals to include the new `run_ldos` field.
- Updated regression operator documentation in `README.md` with LDOS pre-compare execution requirements and output scope.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/regression.rs`, `src/pipelines/ldos.rs`, `tests/ldos_parity.rs`, `tests/band_parity.rs`, `tests/rdinp_parity.rs`, `tests/pot_parity.rs`, `tests/path_parity.rs`, `tests/fms_parity.rs`, `tests/xsph_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: LDOS parity should derive expected outputs from baseline filename families (`ldos*.dat`) plus required logs (`logdos.dat`) so fixture-specific atom-index counts do not require code changes.
  - Gotchas encountered: Regression-suite fixtures that stage module inputs in the same comparison directory must copy those inputs into the temporary baseline root, or regression reports false missing-baseline failures.
  - Useful context: `FX-LDOS-001` parity currently validates text-normalized `ldos.inp`/`geom.dat`/`reciprocal.inp`, byte-exact `pot.bin`, and materializes whatever LDOS output set is present in `artifacts/fortran-baselines/<fixture>/baseline`.
---
## 2026-02-16 20:55:49 JST - US-030
- Implemented baseline-driven RIXS parity module `src/pipelines/rixs.rs` with required staged inputs (`rixs.inp`, `phase_1.bin`, `phase_2.bin`, `wscrn_1.dat`, `wscrn_2.dat`, `xsect_2.dat`), optional baseline-input matching when fixture baselines provide those inputs, and baseline artifact materialization for approved RIXS outputs.
- Integrated RIXS into regression and CLI orchestration by adding `RegressionRunnerConfig.run_rixs`, the `run_rixs_if_enabled` regression hook, and CLI flags `--run-rixs`/`--run-rixs-placeholder`, with README usage updates.
- Added RIXS parity coverage in `tests/rixs_parity.rs` (fixture-level comparator validation plus RIXS-only regression suite pass test) and extended regression runner unit tests with `run_regression_can_execute_rixs_scaffold`; updated existing parity-suite config literals for the new `run_rixs` field.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/regression.rs`, `src/pipelines/rixs.rs`, `tests/rixs_parity.rs`, `tests/band_parity.rs`, `tests/fms_parity.rs`, `tests/ldos_parity.rs`, `tests/path_parity.rs`, `tests/pot_parity.rs`, `tests/rdinp_parity.rs`, `tests/xsph_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: RIXS edge-case fixtures can follow the same baseline-driven parity contract when expected outputs are derived from available baseline files, including reference-named artifacts when canonical `rixs*.dat` outputs are absent.
  - Gotchas encountered: `FX-RIXS-001` baseline snapshots currently provide reference-file outputs (`referenceherfd*.dat`, `referencerixsET.dat`) but omit canonical RIXS staged inputs; parity execution must stage required inputs while gating baseline-input matching on per-file availability.
  - Useful context: Regression now supports `--run-rixs` for fixtures whose `modulesCovered` includes `RIXS`, using `<actual-root>/<fixture>/<actual-subdir>/rixs.inp` as the hook entrypoint and sibling staged input contract.
---
