# Ralph Progress Log
Started: Mon Feb 16 16:57:34 JST 2026
## Codebase Patterns
- Store migration governance decisions under `tasks/` and add a reference from `tasks/prd-migrate-feff10-to-rust-improved.md` for traceability.
- Module-boundary planning artifacts should map every in-scope module to a `PipelineModule` target in `src/domain/mod.rs`, a reserved implementation file under `src/pipelines/`, and at least one fixture ID from `tasks/golden-fixture-manifest.json`.
- Keep story state consistent by updating `scripts/ralph/prd.json` (`passes`) and appending `scripts/ralph/progress.txt` in the same commit.
- For cross-cutting migration decisions, include explicit architecture and CI implications in `tasks/migration-decision-log.md` and mirror the decision status in PRD references.
- When a policy must be machine-consumable, keep a canonical JSON artifact under `tasks/` and document comparator ingestion rules alongside the approval decision.
- For warning/error compatibility decisions, define all three together: exit-code matrix, stderr/stdout formatting contract, and legacy failure-class to Rust error-category mapping.
- Compatibility matrix rows belong in `tasks/feff10-compatibility-matrix.md` and should always include command surface, required cards/options, input/output artifacts, output directory contract, and fixture IDs.
- Fixture manifests should be machine-readable JSON under `tasks/`, must reuse reserved `FX-*` IDs from the compatibility matrix, and must define `comparison.mode` plus `comparison.passFailThreshold` per fixture.
- Baseline capture tooling should treat manifest `entryFiles` as authoritative and materialize `REFERENCE/<file>` inputs from `baselineSources` archives into a flat fixture working directory.
- Baseline snapshot generation should run all fixtures via `scripts/fortran/generate-baseline-snapshots.sh` and emit per-fixture `checksums.sha256` plus `snapshot-metadata.json` under `artifacts/fortran-baselines/`.
- Regression harness fixture layout is `<root>/<fixture-id>/<subdir>`; keep Rust output staging compatible with `--actual-root` plus `--actual-subdir` for `feff10-rs regression`.
- New pipeline scaffolds should integrate into regression as explicit opt-in pre-compare hooks (for example `--run-rdinp-placeholder`) and derive fixture input paths from manifest `modulesCovered` + `inputDirectory` metadata.
- Numeric-tolerance policy globs must only target parseable numeric files; non-numeric headers in matched files (for example `paths.dat`) are reported as comparison failures.
- On this macOS environment, run Rust tests with `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)"` to avoid `ld: library not found for -liconv` from the default linker.
- Keep `src/main.rs` as a thin process entrypoint and route command parsing through `src/cli`, with scientific and regression execution logic grouped under `src/pipelines` and shared contracts in `src/domain`.
- Shared runtime failure handling lives in `src/domain/errors.rs`; parser and pipeline APIs should return `ParserResult`/`PipelineResult`, and CLI fatal output should emit both `ERROR: [TOKEN] ...` and `FATAL EXIT CODE: <n>` from one mapping point.
- FEFF deck parsing should treat numeric-leading lines as continuations of the preceding card (for example `ATOMS`, `POTENTIALS`, `ELNES`, `STRETCHES`) and only fail when such a line appears before any card.
- Parser validation in `src/parser/mod.rs` is profile-driven: main decks require `TITLE|CIF`, `ATOMS|CIF`, and `POTENTIALS|POTENTIAL|CIF`, while DEBYE spring decks require `VDOS` and `STRETCHES`; missing `CONTROL`, `PRINT`, and `END` are synthesized with deterministic defaults.
- Core-science pipeline scaffolds should consume deterministic helpers from `src/numerics/mod.rs` (`deterministic_argsort`, compensated aggregation helpers, and grid/interpolation helpers) instead of local float logic.
- Keep numeric tolerance semantics centralized in `src/numerics/mod.rs` (`NumericTolerance`, policy loader, `compare_with_policy_tolerance`, and `format_numeric_for_policy`) so comparator/reporting logic does not drift from `tasks/numeric-tolerance-policy.json`.
---
## 2026-02-16 17:00:00 JST - US-001
- Implemented the D-1 platform certification matrix with GA/non-GA OS+architecture targets, platform-specific compiler/runtime constraints, and an explicit approval record.
- Added a PRD traceability reference to the finalized D-1 decision log.
- Quality checks: `cargo check` passed.
- Files changed: `tasks/migration-decision-log.md`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Decision-level migration constraints should live in dedicated docs under `tasks/` and be linked from the PRD.
  - Gotchas encountered: `scripts/ralph/progress.txt` may start without a `Codebase Patterns` section; create it at the top before appending story entries.
  - Useful context: Story execution state is controlled only by `passes` in `scripts/ralph/prd.json`; update just the completed story.
---
## 2026-02-16 17:08:01 JST - US-002
- Implemented decision `D-2` in `tasks/migration-decision-log.md`, explicitly deferring MPI parity for v1 and documenting fallback behavior plus a roadmap trigger.
- Added MPI decision traceability in `tasks/prd-migrate-feff10-to-rust-improved.md`, including architecture-planning and CI-planning references to the approved D-2 scope.
- Quality checks: `cargo check` and `cargo test` passed.
- Files changed: `tasks/migration-decision-log.md`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: MPI-scope decisions should include explicit fallback behavior and a concrete re-open trigger so later parity work has clear entry criteria.
  - Gotchas encountered: Acceptance for decision stories can require references in multiple planning surfaces; update both architecture and CI sections, not only the decision log.
  - Useful context: In this repo, architecture and CI planning context is captured in `tasks/prd-migrate-feff10-to-rust-improved.md`, so D-2 references belong there as well as in the decision log.
---
## 2026-02-16 17:11:56 JST - US-003
- Implemented decision `D-3` in `tasks/migration-decision-log.md` with an output-category policy matrix that defines exact-text vs numeric-tolerance comparison modes and approved absolute/relative tolerances.
- Added machine-readable comparator policy file `tasks/numeric-tolerance-policy.json`, including category match order, numeric parsing rules, and per-category thresholds.
- Added D-3 traceability in `tasks/prd-migrate-feff10-to-rust-improved.md`, pointing to both the decision log and the JSON policy artifact.
- Quality checks: `cargo check` and `cargo test` passed; `jq empty tasks/numeric-tolerance-policy.json` passed.
- Files changed: `tasks/migration-decision-log.md`, `tasks/numeric-tolerance-policy.json`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Comparator-facing governance decisions should include both a human-readable matrix in the decision log and a canonical machine-readable JSON file.
  - Gotchas encountered: Category ordering now matters (`first_match`); broad glob patterns must be kept below specific patterns to avoid unintended rule capture.
  - Useful context: Numeric parsing explicitly supports Fortran `D` exponents and defaults unmatched files to `exact_text`, which future comparator implementation should preserve.
---
## 2026-02-16 17:14:46 JST - US-004
- Implemented decision `D-4` in `tasks/migration-decision-log.md` with a finalized warning/error compatibility contract, including exit-code mapping for success/failure modes, deterministic stderr/stdout behavior, and legacy failure-class mapping to Rust error categories.
- Added architecture and CI implications for `D-4` to keep downstream implementation and validation stories aligned with the contract.
- Added D-4 traceability in `tasks/prd-migrate-feff10-to-rust-improved.md`.
- Quality checks: `cargo check` and `cargo test` passed.
- Files changed: `tasks/migration-decision-log.md`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Warning/error compatibility must capture both process semantics (exit code) and text-stream semantics (`stderr`/`stdout` prefixes) to avoid breaking legacy automation.
  - Gotchas encountered: For compatibility stories, acceptance can require explicit mapping tables (legacy class to Rust category), not only prose decisions.
  - Useful context: `D-4` now reserves exit codes `2`-`5` for fatal categories and keeps warning-only runs at exit code `0`.
---
## 2026-02-16 17:21:39 JST - US-005
- Published canonical compatibility matrix `tasks/feff10-compatibility-matrix.md` covering all in-scope modules with required CLI surfaces, options/cards, input/output artifacts, output directory contracts, and fixture traceability IDs.
- Added PRD traceability references to the compatibility matrix in `tasks/prd-migrate-feff10-to-rust-improved.md`.
- Quality checks: `cargo check` and `cargo test` passed.
- Files changed: `tasks/feff10-compatibility-matrix.md`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Compatibility matrix deliverables should keep module contracts in one canonical document under `tasks/` and include fixture IDs that future manifest work must reuse verbatim.
  - Gotchas encountered: Some scoped modules (`DEBYE`, `SELF`) do not have standalone executables; their CLI contracts are through host modules (`ff2x` and `sfconv`) and must be modeled that way.
  - Useful context: The matrix is grounded in Fortran module headers plus source-level `open(file=...)` contracts, which gives a concrete baseline for later regression harness implementation.
---
## 2026-02-16 17:28:30 JST - US-006
- Created canonical fixture manifest `tasks/golden-fixture-manifest.json` with all reserved fixture IDs, including at least one fixture per in-scope module and end-to-end workflow fixture `FX-WORKFLOW-XAS-001`.
- Added per-fixture comparison contracts (`comparison.mode` and `comparison.passFailThreshold`) and documented four edge-case fixtures (`FX-RIXS-001`, `FX-DMDW-001`, `FX-SCREEN-001`, `FX-FULLSPECTRUM-001`).
- Added PRD traceability status in `tasks/prd-migrate-feff10-to-rust-improved.md` for the published fixture manifest.
- Quality checks: `jq empty tasks/golden-fixture-manifest.json`, `cargo check`, and `cargo test` passed.
- Files changed: `tasks/golden-fixture-manifest.json`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Fixture definitions are most reusable when each fixture includes module coverage, concrete input paths, baseline source metadata, and explicit comparison/pass-threshold settings.
  - Gotchas encountered: Some module fixtures (`BAND`, `FULLSPECTRUM`) have seed inputs in reference archives but require dedicated Fortran baseline capture in later stories; this iteration assumes that is acceptable because baseline generation is scoped to `US-007` and `US-008`.
  - Useful context: `feff10/examples/MPSE/Cu_OPCONS/REFERENCE.zip` contains both `screen.inp` and `sfconv.inp` plus `logscreen.dat`/`logsfconv.dat`, making it the best shared source for `SCREEN` and `SELF` fixture coverage.
---
## 2026-02-16 17:37:04 JST - US-007
- Implemented `scripts/fortran/capture-baselines.sh` to read `tasks/golden-fixture-manifest.json`, select fixtures (`--fixture`/`--fixtures`/`--all-fixtures`, defaulting to `requires_fortran_capture`), stage deterministic per-fixture `inputs/`, `outputs/`, and `logs/` directories, and execute Fortran captures through either `--runner` or `--bin-dir`.
- Added strict failure handling so any fixture materialization or execution error is reported and causes a non-zero process exit after summary reporting.
- Added `scripts/fortran/tests/test-capture-baselines.sh` to validate deterministic output-tree resets and non-zero exit behavior when a fixture run fails.
- Quality checks: `cargo check`, `cargo test`, and `scripts/fortran/tests/test-capture-baselines.sh` passed.
- Files changed: `scripts/fortran/capture-baselines.sh`, `scripts/fortran/tests/test-capture-baselines.sh`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: For capture automation, `--runner` mode is the lowest-friction integration path when teams already have a stable Fortran orchestration command.
  - Gotchas encountered: `FX-BAND-001` currently references `REFERENCE/band.inp`, but that file is absent from `feff10/examples/KSPACE/Cr2GeC/REFERENCE.zip`; default capture therefore reports a fixture failure until that input contract is corrected.
  - Useful context: With `set -o pipefail`, archive-entry checks should avoid `grep -q` on `unzip -Z1` pipelines to prevent false negatives from SIGPIPE.
---
## 2026-02-16 17:47:02 JST - US-008
- Implemented `scripts/fortran/generate-baseline-snapshots.sh` to run capture for `--all-fixtures`, materialize baseline artifacts from fixture `baselineSources` (`reference_archive` and `reference_file`), and write committed fixture snapshots under `artifacts/fortran-baselines/`.
- Added reproducibility metadata for each fixture via `checksums.sha256` and `snapshot-metadata.json`, plus top-level snapshot index `artifacts/fortran-baselines/snapshot-index.json`.
- Extended `scripts/fortran/capture-baselines.sh` with `--allow-missing-entry-files` so full-manifest capture can proceed while recording unresolved entries in metadata.
- Documented snapshot regeneration command and prerequisites in `README.md`.
- Quality checks: `cargo check`, `cargo test`, `scripts/fortran/tests/test-capture-baselines.sh`, and `scripts/fortran/tests/test-generate-baseline-snapshots.sh` passed.
- Files changed: `README.md`, `scripts/fortran/capture-baselines.sh`, `scripts/fortran/generate-baseline-snapshots.sh`, `scripts/fortran/tests/test-capture-baselines.sh`, `scripts/fortran/tests/test-generate-baseline-snapshots.sh`, `artifacts/fortran-baselines/*`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Snapshot generation should copy seeded capture outputs first, then overlay `baselineSources` so archive/file references become the canonical baseline view per fixture.
  - Gotchas encountered: `FX-BAND-001` still lacks `REFERENCE/band.inp` in its source archive; this run records it under `missingEntryFiles` while retaining a checksumed baseline from available artifacts.
  - Useful context: `snapshot-index.json` now contains `checksummedFileCount` and `missingEntryFiles` for every fixture, which can be consumed by upcoming comparator/runner stories.
---
## 2026-02-16 17:55:42 JST - US-009
- Implemented Rust comparator core in `src/comparator.rs`, including policy loading from JSON, ordered glob-based rule selection, and per-artifact exact-text or numeric-tolerance evaluation.
- Added structured comparison outputs (`ArtifactComparisonResult` + metrics enums) and batch comparison support via `Comparator::compare_artifacts`.
- Added unit tests for policy ingestion, first-match category behavior, exact-text mismatch reporting, numeric tolerance pass/fail behavior, Fortran `D` exponent parsing, and per-artifact result aggregation.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `Cargo.toml`, `Cargo.lock`, `src/lib.rs`, `src/comparator.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Comparator policy matching should preserve category order (`first_match`), so broad globs must be placed below specific globs.
  - Gotchas encountered: On this machine, plain `cargo test` fails to link `-liconv`; use the clang linker override command from `Codebase Patterns`.
  - Useful context: `Comparator::compare_artifacts` already yields structured per-artifact results, so `US-010` can consume it directly for summary/report generation.
---
## 2026-02-16 18:03:49 JST - US-010
- Implemented regression runner core in `src/regression.rs`, including manifest-driven fixture enumeration, per-artifact comparison against baselines using `Comparator`, fixture-level threshold evaluation, human-readable summary rendering, and JSON report emission.
- Replaced `src/main.rs` with a real CLI command (`feff10-rs regression`) that runs all fixtures in one command, supports configurable manifest/policy/root/subdir/report paths, and exits with status `1` when any fixture fails.
- Added regression coverage with unit tests in `src/regression.rs` and integration CLI tests in `tests/regression_cli.rs` to verify summary/report behavior and non-zero exit on failures.
- Documented runner invocation and report output in `README.md`.
- Quality checks: `cargo fmt --all`, `cargo check`, `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test`, and `cargo run -- regression` (expected non-zero with current policy/file-match set) completed.
- Files changed: `README.md`, `src/lib.rs`, `src/main.rs`, `src/regression.rs`, `tests/regression_cli.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Keep generated Rust fixture outputs in a deterministic `<root>/<fixture-id>/<subdir>` layout so they can be consumed directly by `feff10-rs regression --actual-root ... --actual-subdir ...`.
  - Gotchas encountered: Current numeric policy matches `paths.dat` under numeric tolerance, but those files include non-numeric tokens; the runner will correctly mark these as failures until policy globs or file formatting are aligned.
  - Useful context: Default runner config compares `artifacts/fortran-baselines/<fixture>/baseline` to the same layout and writes machine-readable results to `artifacts/regression/report.json`; pass real Rust outputs via `--actual-root`/`--actual-subdir`.
---
## 2026-02-16 18:09:01 JST - US-011
- Implemented Rust workspace scaffolding boundaries in the main crate by adding dedicated modules for `cli`, `domain`, `parser`, `numerics`, and `pipelines`.
- Moved comparator/regression infrastructure into `src/pipelines/` and kept behavior stable by routing binary startup through `src/cli::run_from_env()` with a thin `src/main.rs`.
- Added shared domain contracts (`PipelineModule`, `PipelineRequest`, input deck/card types), parser scaffolding entrypoint, numerics helper primitives, and pipeline abstraction interfaces with focused unit tests.
- Documented the scaffolded architecture layout in `README.md` to keep future module-port stories aligned with the PRD boundary guidance.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/lib.rs`, `src/main.rs`, `src/cli/mod.rs`, `src/domain/mod.rs`, `src/parser/mod.rs`, `src/numerics/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/comparator.rs`, `src/pipelines/regression.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Shared FEFF contracts should live in `src/domain`, and runtime orchestration code should remain isolated under `src/pipelines` so module ports can plug into stable interfaces.
  - Gotchas encountered: `cargo test` still requires the clang linker override on this macOS host; keep using the environment variable from `Codebase Patterns`.
  - Useful context: Existing regression behavior is now accessed through `crate::pipelines::regression`, so future pipeline stories can evolve module execution without changing CLI argument contracts.
---
## 2026-02-16 18:15:21 JST - US-012
- Implemented shared error/result infrastructure in `src/domain/errors.rs`, including D-4-aligned category enum (`Success`, `InputValidationError`, `IoSystemError`, `ComputationError`, `InternalError`), shared result aliases, and compatibility placeholder mapping (`exit_code`, Rust category token, legacy class token).
- Integrated shared error conventions across parser and pipeline surfaces by switching `parse_input_deck` to `ParserResult<InputDeck>`, updating `PipelineExecutor` to `PipelineResult`, and making `run_regression` return `PipelineResult<RegressionRunReport>`.
- Added error-category bridging from comparator/regression internals to shared `FeffError`, and centralized CLI fatal diagnostics/exit behavior to emit `ERROR: [TOKEN] ...` plus `FATAL EXIT CODE: <n>` via shared mapping.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `src/domain/errors.rs`, `src/domain/mod.rs`, `src/parser/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/comparator.rs`, `src/pipelines/regression.rs`, `src/cli/mod.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Shared parser/pipeline APIs should return `ParserResult`/`PipelineResult` aliases so compatibility exit mapping remains centralized in `FeffError`.
  - Gotchas encountered: `run_regression` now returns shared `FeffError`; callers that previously expected `RegressionRunnerError` should handle categorized errors instead of internal variants.
  - Useful context: CLI runtime errors now derive exit code from `FeffError::exit_code()` and print the D-4-compatible diagnostic pair, while parity mismatches still return `Ok(1)` without fatal-error formatting.
---
## 2026-02-16 18:20:06 JST - US-013
- Added `tasks/fortran-rust-boundary-map.md` as the canonical module-boundary artifact mapping every in-scope Fortran module to planned Rust workspace targets (`src/pipelines/*` + `PipelineModule` variants), with fixture traceability for each mapping.
- Documented dependency-ordered implementation sequencing with explicit parallelization windows and required upstream artifact contracts derived from the compatibility matrix.
- Added PRD traceability reference to the boundary-map artifact in `tasks/prd-migrate-feff10-to-rust-improved.md`.
- Quality checks: `cargo check` passed; `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `tasks/fortran-rust-boundary-map.md`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Boundary-map docs are most reusable when each module row includes all three anchors: Rust target path, `PipelineModule` variant, and fixture IDs.
  - Gotchas encountered: The `SELF` module should map to `PipelineModule::SelfEnergy` and `src/pipelines/self_energy.rs` to avoid Rust keyword conflicts while preserving FEFF naming externally.
  - Useful context: Sequencing should follow artifact contracts from `tasks/feff10-compatibility-matrix.md` (for example `XSPH` depends on `pot.bin`, while `PATH`/`FMS` depend on `phase.bin`).
---
## 2026-02-16 18:28:25 JST - US-014
- Implemented a tokenizer + typed AST parser for FEFF input decks by extending `src/parser/mod.rs` with `tokenize_input_deck`, card-kind classification, and continuation-line handling for numeric/table sections.
- Added typed parser domain contracts in `src/domain/mod.rs` (`InputCardKind`, `InputCardContinuation`) and preserved unknown card tokens via `InputCardKind::Unknown(...)` for downstream validation/diagnostics.
- Added pipeline-facing consumption helper `cards_for_pipeline_request` in `src/pipelines/mod.rs` so pipeline entrypoints can consume typed parser cards by requested module.
- Added fixture-driven parser coverage in `tests/parser_fixture_inputs.rs` to parse all existing `.inp` entry files referenced by `tasks/golden-fixture-manifest.json` and assert there are no uncovered card keywords.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `src/domain/mod.rs`, `src/parser/mod.rs`, `src/pipelines/mod.rs`, `tests/parser_fixture_inputs.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Parser output should include both typed card kinds and raw continuation rows so RDINP/module pipelines can consume structured cards without losing table data.
  - Gotchas encountered: Fixture manifests can reference archive-only entries that are not present in-repo (`REFERENCE/*.inp`), so parser coverage tests should skip missing files but still validate all available `.inp` entry files.
  - Useful context: Cards currently covered from approved fixtures include `ELNES`/`EXELFS`, `RIXS`, `COMPTON`, `CRPA`, `VDOS`, and `STRETCHES`, alongside core cards such as `POTENTIALS` and `ATOMS`.
---
## 2026-02-16 18:36:15 JST - US-015
- Implemented parser validation profiles in `src/parser/mod.rs` so main FEFF decks and DEBYE spring decks enforce deterministic required-card and singleton-card rules.
- Added optional-card defaults for `CONTROL`, `PRINT`, and `END`, and mapped parse-validation failures to shared D-4-compatible `InputValidationError` placeholders and exit code behavior.
- Added deterministic parser snapshot coverage in `tests/parser_validation_snapshots.rs` with committed snapshots under `tests/snapshots/parser/`.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `src/parser/mod.rs`, `tests/parser_validation_snapshots.rs`, `tests/snapshots/parser/valid_main_deck_with_defaults.snap`, `tests/snapshots/parser/invalid_missing_required_cards.snap`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Parser validation now switches behavior by profile (`main` vs `spring`) so `feff.inp` and `spring.inp` contracts can coexist in one parser entrypoint.
  - Gotchas encountered: In `zsh`, avoid using `path` as a loop variable because it overrides `PATH` and makes shell commands unavailable.
  - Useful context: Parser snapshot tests compare pretty-JSON output against `tests/snapshots/parser/*.snap`, so parser contract changes should update those snapshot files in the same commit.
---
## 2026-02-16 18:41:01 JST - US-016
- Implemented shared numerics foundation in `src/numerics/mod.rs` with deterministic `f64` APIs for compensated aggregation (`stable_sum`, weighted sum/mean), 3D geometry distance helpers, deterministic numeric ordering (`deterministic_argsort`), and linear grid/interpolation primitives.
- Added focused numerics unit coverage for aggregation edge cases, deterministic ordering behavior, geometry helpers, and interpolation/grid validation.
- Integrated numerics with a core pipeline scaffold by adding `CorePipelineScaffold` in `src/pipelines/mod.rs`, which now uses numerics helpers for deterministic neighbor-shell ordering and weighted channel aggregation across core modules (`RDINP`, `POT`, `PATH`, `FMS`, `XSPH`).
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `src/numerics/mod.rs`, `src/pipelines/mod.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Keep float ordering deterministic by sorting indices with `total_cmp` plus index tie-breaks instead of relying on unstable equal-value ordering.
  - Gotchas encountered: Weighted aggregation helpers should reject zero total weight and mismatched vector lengths so module scaffolds fail fast before parity logic is added.
  - Useful context: `CorePipelineScaffold::new` intentionally gates to core modules only; non-core modules return `None`, which keeps the scaffold contract aligned with core-chain scope.
---
## 2026-02-16 18:50:19 JST - US-017
- Added numerics precision helpers in `src/numerics/mod.rs`: shared `NumericTolerance` type, policy loader (`load_numeric_tolerance_policy`), policy-aligned tolerance comparison (`compare_with_policy_tolerance`), and deterministic numeric formatting (`format_numeric_for_policy`).
- Wired `src/pipelines/comparator.rs` to reuse the numerics precision helpers so comparator pass/fail math and diagnostic formatting stay aligned with `tasks/numeric-tolerance-policy.json`.
- Added baseline-backed reference tests in `tests/numerics_reference_data.rs` using approved fixture snapshots (`FX-EELS-001`, `FX-LDOS-001`, `FX-PATH-001`) to validate compensated sums, weighted means, interpolation, deterministic ordering, and grid generation against fixed reference values under policy-derived tolerances.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `src/numerics/mod.rs`, `src/pipelines/comparator.rs`, `tests/numerics_reference_data.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Use `load_numeric_tolerance_policy(...).tolerance_for_category(...)` in tests/helpers instead of hardcoding thresholds so numerics checks stay synchronized with the canonical policy JSON.
  - Gotchas encountered: Floating-point boundary assertions can fail on exact-equality tolerance edges; keep assertions away from threshold boundaries to avoid flaky tests.
  - Useful context: `emesh.dat` contains a non-monotonic tail segment, so grid/interpolation reference checks should target the monotonic prefix region.
---
## 2026-02-16 18:58:31 JST - US-018
- Added RDINP scaffold entrypoint in `src/pipelines/rdinp.rs` with compatibility-matrix interfaces: required input artifact `feff.inp`, deterministic expected output artifact set, module/input validation, and optional `screen.inp` output when the input deck includes a `SCREEN` card.
- Wired RDINP scaffold execution into regression via `RegressionRunnerConfig.run_rdinp_placeholder`, including manifest-driven fixture metadata parsing (`modulesCovered`, `inputDirectory`, `entryFiles`) and a guarded pre-comparison execution hook.
- Exposed Rust-path enablement through CLI flag `--run-rdinp-placeholder` and documented the flag in `README.md`.
- Added tests for RDINP contract/output materialization and regression hook behavior (`run_regression_can_execute_rdinp_placeholder_path`).
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/regression.rs`, `src/pipelines/rdinp.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Pipeline scaffolds can be integrated safely by running them as opt-in regression pre-hooks keyed by fixture `modulesCovered`, which keeps unfinished Rust paths from altering default regression behavior.
  - Gotchas encountered: Manifest fixtures used for scaffold execution must include `inputDirectory`; otherwise regression should fail early with an input-validation error instead of silently skipping execution.
  - Useful context: `RdinpPipelineScaffold` writes placeholder artifacts into `<actual-root>/<fixture-id>/<actual-subdir>` and returns the artifact list, so later parity stories can swap the placeholder writer for real RDINP generation without changing regression wiring.
---
