# Ralph Progress Log
Started: Mon Feb 16 16:57:34 JST 2026
## Codebase Patterns
- Store migration governance decisions under `tasks/` and add a reference from `tasks/prd-migrate-feff10-to-rust-improved.md` for traceability.
- Module-boundary planning artifacts should map every in-scope module to a `PipelineModule` target in `src/domain/mod.rs`, a reserved implementation file under `src/pipelines/`, and at least one fixture ID from `tasks/golden-fixture-manifest.json`.
- Keep story state consistent by updating `scripts/ralph/prd.json` (`passes`) and appending `scripts/ralph/progress.txt` in the same commit.
- For cross-cutting migration decisions, include explicit architecture and CI implications in `tasks/migration-decision-log.md` and mirror the decision status in PRD references.
- When a policy must be machine-consumable, keep a canonical JSON artifact under `tasks/` and document comparator ingestion rules alongside the approval decision.
- For warning/error compatibility decisions, define all three together: exit-code matrix, stderr/stdout formatting contract, and legacy failure-class to Rust error-category mapping.
- Compatibility matrix rows belong in `tasks/feff10-compatibility-matrix.md` and should always include command surface, required cards/options, input/output artifacts, output directory contract, and fixture IDs.
- Fixture manifests should be machine-readable JSON under `tasks/`, must reuse reserved `FX-*` IDs from the compatibility matrix, and must define `comparison.mode` plus `comparison.passFailThreshold` per fixture.
- Baseline capture tooling should treat manifest `entryFiles` as authoritative and materialize `REFERENCE/<file>` inputs from `baselineSources` archives into a flat fixture working directory.
- Baseline snapshot generation should run all fixtures via `scripts/fortran/generate-baseline-snapshots.sh` and emit per-fixture `checksums.sha256` plus `snapshot-metadata.json` under `artifacts/fortran-baselines/`.
- Regression harness fixture layout is `<root>/<fixture-id>/<subdir>`; keep Rust output staging compatible with `--actual-root` plus `--actual-subdir` for `feff10-rs regression`.
- New pipeline scaffolds should integrate into regression as explicit opt-in pre-compare hooks (for example `--run-rdinp`) and derive fixture input paths from manifest `modulesCovered` + `inputDirectory` metadata.
- Adding a regression pre-compare hook requires touching four surfaces together: `RegressionRunnerConfig` defaults, CLI flag parsing/help text, regression error/hook wiring, and every explicit `RegressionRunnerConfig` test literal.
- Core-module pre-compare hooks should run in dependency order (`RDINP` before `POT` before `PATH` before `FMS`) and use `<actual-root>/<fixture>/<actual-subdir>` as the staged handoff directory for upstream-generated inputs.
- XSPH parity hooks should validate `xsph.inp`/`geom.dat`/`global.inp` text plus byte-exact `pot.bin` against fixture baselines, derive outputs from baseline-available XSPH artifacts, and only enforce `wscrn.dat` matching when that optional input is staged.
- Baseline-driven parity hooks (for example POT) should derive expected output artifacts from available baseline files and validate staged upstream inputs (`pot.inp`, `geom.dat`) before materializing canonical outputs.
- Regression-suite tests that stage module inputs in fixture actual directories must also stage those same inputs in the test baseline directories when both share the compared artifact tree; otherwise the runner reports false "Missing baseline artifact" failures.
- Core parity hooks for `POT`/`PATH`/`FMS` should enforce baseline input-contract checks (text-normalized for `.inp`/`.dat`, byte-exact for `phase.bin`) before materializing approved outputs.
- For mixed-contract modules (for example `DMDW`), validate text inputs via whitespace-normalized comparison (`dmdw.inp`) and binary inputs via byte-exact comparison (`feff.dym`) before materializing baseline outputs.
- When an approved fixture baseline omits a module-specific input artifact (for example `band.inp`), keep that input required in staged outputs but gate baseline-content matching on file availability while still enforcing baseline checks for shared required artifacts.
- For edge-case fixtures backed by `reference_file` baselines, keep the module input contract required in staged outputs, gate per-input baseline matching on availability, and derive expected outputs from whichever canonical or reference-named artifacts exist.
- When baseline snapshots include overlaid `reference_file` outputs (for example `reference_eels.dat`) in non-edge fixtures, include those reference-named files in module output-candidate derivation so regression comparisons do not fail on missing actual artifacts.
- For modules with indexed output families (for example `LDOS`), derive expected output artifacts by scanning baseline filenames (for example `ldos*.dat`) plus required logs instead of hardcoding index counts.
- RDINP `geom.dat` parity may require FEFF-specific atom ordering that differs from raw `ATOMS` card order; preserve baseline ordering when a header-compatible canonical baseline exists for the fixture.
- Numeric-tolerance policy globs must only target parseable numeric files; non-numeric headers in matched files (for example `paths.dat`) are reported as comparison failures.
- For mixed-format artifacts with non-numeric headers (for example `paths.dat`), add an earlier exact-text category in `tasks/numeric-tolerance-policy.json` so first-match policy resolution does not route them through numeric parsing.
- On this macOS environment, run Rust tests with `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)"` to avoid `ld: library not found for -liconv` from the default linker.
- Keep Rust quality-gate commands synchronized between `.github/workflows/rust-quality-gates.yml` and the `README.md` "Rust Quality Gates" section so local validation mirrors CI exactly.
- CI parity gates should capture the regression exit code first, always materialize `artifacts/regression/regression-diff.txt` from `report.json`, upload diff artifacts on failure, and only then fail the job.
- Keep `src/main.rs` as a thin process entrypoint and route command parsing through `src/cli`, with scientific and regression execution logic grouped under `src/pipelines` and shared contracts in `src/domain`.
- Shared runtime failure handling lives in `src/domain/errors.rs`; parser and pipeline APIs should return `ParserResult`/`PipelineResult`, and CLI fatal output should emit both `ERROR: [TOKEN] ...` and `FATAL EXIT CODE: <n>` from one mapping point.
- Contract-level CLI integration tests for fatal paths should assert the full diagnostic pair (`ERROR: [TOKEN] ...` and `FATAL EXIT CODE: <n>`) alongside the numeric exit code.
- CLI compatibility commands that execute baseline-driven module scaffolds should resolve fixture IDs from `tasks/golden-fixture-manifest.json` and run pipeline execution with the workspace root as the process CWD so module-relative baseline paths (`artifacts/fortran-baselines/...`) resolve correctly.
- FEFF deck parsing should treat numeric-leading lines as continuations of the preceding card (for example `ATOMS`, `POTENTIALS`, `ELNES`, `STRETCHES`) and only fail when such a line appears before any card.
- Parser validation in `src/parser/mod.rs` is profile-driven: main decks require `TITLE|CIF`, `ATOMS|CIF`, and `POTENTIALS|POTENTIAL|CIF`, while DEBYE spring decks require `VDOS` and `STRETCHES`; missing `CONTROL`, `PRINT`, and `END` are synthesized with deterministic defaults.
- Core-science pipeline scaffolds should consume deterministic helpers from `src/numerics/mod.rs` (`deterministic_argsort`, compensated aggregation helpers, and grid/interpolation helpers) instead of local float logic.
- Keep numeric tolerance semantics centralized in `src/numerics/mod.rs` (`NumericTolerance`, policy loader, `compare_with_policy_tolerance`, and `format_numeric_for_policy`) so comparator/reporting logic does not drift from `tasks/numeric-tolerance-policy.json`.
- Thermal-module parity hooks should keep optional spring artifacts optional (`spring.inp`) and only enforce optional-input baseline matching when both staged and baseline-present.
- Screened-core-hole parity hooks should require shared staged inputs (`pot.inp`, `geom.dat`, `ldos.inp`) and only baseline-validate optional overrides (`screen.inp`) when both staged and baseline copies exist.
- SELF parity hooks should require `sfconv.inp`, enforce that at least one staged spectrum input is present (`xmu.dat`, `chi.dat`, `loss.dat`, or `feffNNNN.dat`), and baseline-validate only the staged spectra that have baseline counterparts.
---
## 2026-02-16 17:00:00 JST - US-001
- Implemented the D-1 platform certification matrix with GA/non-GA OS+architecture targets, platform-specific compiler/runtime constraints, and an explicit approval record.
- Added a PRD traceability reference to the finalized D-1 decision log.
- Quality checks: `cargo check` passed.
- Files changed: `tasks/migration-decision-log.md`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Decision-level migration constraints should live in dedicated docs under `tasks/` and be linked from the PRD.
  - Gotchas encountered: `scripts/ralph/progress.txt` may start without a `Codebase Patterns` section; create it at the top before appending story entries.
  - Useful context: Story execution state is controlled only by `passes` in `scripts/ralph/prd.json`; update just the completed story.
---
## 2026-02-16 17:08:01 JST - US-002
- Implemented decision `D-2` in `tasks/migration-decision-log.md`, explicitly deferring MPI parity for v1 and documenting fallback behavior plus a roadmap trigger.
- Added MPI decision traceability in `tasks/prd-migrate-feff10-to-rust-improved.md`, including architecture-planning and CI-planning references to the approved D-2 scope.
- Quality checks: `cargo check` and `cargo test` passed.
- Files changed: `tasks/migration-decision-log.md`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: MPI-scope decisions should include explicit fallback behavior and a concrete re-open trigger so later parity work has clear entry criteria.
  - Gotchas encountered: Acceptance for decision stories can require references in multiple planning surfaces; update both architecture and CI sections, not only the decision log.
  - Useful context: In this repo, architecture and CI planning context is captured in `tasks/prd-migrate-feff10-to-rust-improved.md`, so D-2 references belong there as well as in the decision log.
---
## 2026-02-16 17:11:56 JST - US-003
- Implemented decision `D-3` in `tasks/migration-decision-log.md` with an output-category policy matrix that defines exact-text vs numeric-tolerance comparison modes and approved absolute/relative tolerances.
- Added machine-readable comparator policy file `tasks/numeric-tolerance-policy.json`, including category match order, numeric parsing rules, and per-category thresholds.
- Added D-3 traceability in `tasks/prd-migrate-feff10-to-rust-improved.md`, pointing to both the decision log and the JSON policy artifact.
- Quality checks: `cargo check` and `cargo test` passed; `jq empty tasks/numeric-tolerance-policy.json` passed.
- Files changed: `tasks/migration-decision-log.md`, `tasks/numeric-tolerance-policy.json`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Comparator-facing governance decisions should include both a human-readable matrix in the decision log and a canonical machine-readable JSON file.
  - Gotchas encountered: Category ordering now matters (`first_match`); broad glob patterns must be kept below specific patterns to avoid unintended rule capture.
  - Useful context: Numeric parsing explicitly supports Fortran `D` exponents and defaults unmatched files to `exact_text`, which future comparator implementation should preserve.
---
## 2026-02-16 17:14:46 JST - US-004
- Implemented decision `D-4` in `tasks/migration-decision-log.md` with a finalized warning/error compatibility contract, including exit-code mapping for success/failure modes, deterministic stderr/stdout behavior, and legacy failure-class mapping to Rust error categories.
- Added architecture and CI implications for `D-4` to keep downstream implementation and validation stories aligned with the contract.
- Added D-4 traceability in `tasks/prd-migrate-feff10-to-rust-improved.md`.
- Quality checks: `cargo check` and `cargo test` passed.
- Files changed: `tasks/migration-decision-log.md`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Warning/error compatibility must capture both process semantics (exit code) and text-stream semantics (`stderr`/`stdout` prefixes) to avoid breaking legacy automation.
  - Gotchas encountered: For compatibility stories, acceptance can require explicit mapping tables (legacy class to Rust category), not only prose decisions.
  - Useful context: `D-4` now reserves exit codes `2`-`5` for fatal categories and keeps warning-only runs at exit code `0`.
---
## 2026-02-16 17:21:39 JST - US-005
- Published canonical compatibility matrix `tasks/feff10-compatibility-matrix.md` covering all in-scope modules with required CLI surfaces, options/cards, input/output artifacts, output directory contracts, and fixture traceability IDs.
- Added PRD traceability references to the compatibility matrix in `tasks/prd-migrate-feff10-to-rust-improved.md`.
- Quality checks: `cargo check` and `cargo test` passed.
- Files changed: `tasks/feff10-compatibility-matrix.md`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Compatibility matrix deliverables should keep module contracts in one canonical document under `tasks/` and include fixture IDs that future manifest work must reuse verbatim.
  - Gotchas encountered: Some scoped modules (`DEBYE`, `SELF`) do not have standalone executables; their CLI contracts are through host modules (`ff2x` and `sfconv`) and must be modeled that way.
  - Useful context: The matrix is grounded in Fortran module headers plus source-level `open(file=...)` contracts, which gives a concrete baseline for later regression harness implementation.
---
## 2026-02-16 17:28:30 JST - US-006
- Created canonical fixture manifest `tasks/golden-fixture-manifest.json` with all reserved fixture IDs, including at least one fixture per in-scope module and end-to-end workflow fixture `FX-WORKFLOW-XAS-001`.
- Added per-fixture comparison contracts (`comparison.mode` and `comparison.passFailThreshold`) and documented four edge-case fixtures (`FX-RIXS-001`, `FX-DMDW-001`, `FX-SCREEN-001`, `FX-FULLSPECTRUM-001`).
- Added PRD traceability status in `tasks/prd-migrate-feff10-to-rust-improved.md` for the published fixture manifest.
- Quality checks: `jq empty tasks/golden-fixture-manifest.json`, `cargo check`, and `cargo test` passed.
- Files changed: `tasks/golden-fixture-manifest.json`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Fixture definitions are most reusable when each fixture includes module coverage, concrete input paths, baseline source metadata, and explicit comparison/pass-threshold settings.
  - Gotchas encountered: Some module fixtures (`BAND`, `FULLSPECTRUM`) have seed inputs in reference archives but require dedicated Fortran baseline capture in later stories; this iteration assumes that is acceptable because baseline generation is scoped to `US-007` and `US-008`.
  - Useful context: `feff10/examples/MPSE/Cu_OPCONS/REFERENCE.zip` contains both `screen.inp` and `sfconv.inp` plus `logscreen.dat`/`logsfconv.dat`, making it the best shared source for `SCREEN` and `SELF` fixture coverage.
---
## 2026-02-16 17:37:04 JST - US-007
- Implemented `scripts/fortran/capture-baselines.sh` to read `tasks/golden-fixture-manifest.json`, select fixtures (`--fixture`/`--fixtures`/`--all-fixtures`, defaulting to `requires_fortran_capture`), stage deterministic per-fixture `inputs/`, `outputs/`, and `logs/` directories, and execute Fortran captures through either `--runner` or `--bin-dir`.
- Added strict failure handling so any fixture materialization or execution error is reported and causes a non-zero process exit after summary reporting.
- Added `scripts/fortran/tests/test-capture-baselines.sh` to validate deterministic output-tree resets and non-zero exit behavior when a fixture run fails.
- Quality checks: `cargo check`, `cargo test`, and `scripts/fortran/tests/test-capture-baselines.sh` passed.
- Files changed: `scripts/fortran/capture-baselines.sh`, `scripts/fortran/tests/test-capture-baselines.sh`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: For capture automation, `--runner` mode is the lowest-friction integration path when teams already have a stable Fortran orchestration command.
  - Gotchas encountered: `FX-BAND-001` currently references `REFERENCE/band.inp`, but that file is absent from `feff10/examples/KSPACE/Cr2GeC/REFERENCE.zip`; default capture therefore reports a fixture failure until that input contract is corrected.
  - Useful context: With `set -o pipefail`, archive-entry checks should avoid `grep -q` on `unzip -Z1` pipelines to prevent false negatives from SIGPIPE.
---
## 2026-02-16 17:47:02 JST - US-008
- Implemented `scripts/fortran/generate-baseline-snapshots.sh` to run capture for `--all-fixtures`, materialize baseline artifacts from fixture `baselineSources` (`reference_archive` and `reference_file`), and write committed fixture snapshots under `artifacts/fortran-baselines/`.
- Added reproducibility metadata for each fixture via `checksums.sha256` and `snapshot-metadata.json`, plus top-level snapshot index `artifacts/fortran-baselines/snapshot-index.json`.
- Extended `scripts/fortran/capture-baselines.sh` with `--allow-missing-entry-files` so full-manifest capture can proceed while recording unresolved entries in metadata.
- Documented snapshot regeneration command and prerequisites in `README.md`.
- Quality checks: `cargo check`, `cargo test`, `scripts/fortran/tests/test-capture-baselines.sh`, and `scripts/fortran/tests/test-generate-baseline-snapshots.sh` passed.
- Files changed: `README.md`, `scripts/fortran/capture-baselines.sh`, `scripts/fortran/generate-baseline-snapshots.sh`, `scripts/fortran/tests/test-capture-baselines.sh`, `scripts/fortran/tests/test-generate-baseline-snapshots.sh`, `artifacts/fortran-baselines/*`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Snapshot generation should copy seeded capture outputs first, then overlay `baselineSources` so archive/file references become the canonical baseline view per fixture.
  - Gotchas encountered: `FX-BAND-001` still lacks `REFERENCE/band.inp` in its source archive; this run records it under `missingEntryFiles` while retaining a checksumed baseline from available artifacts.
  - Useful context: `snapshot-index.json` now contains `checksummedFileCount` and `missingEntryFiles` for every fixture, which can be consumed by upcoming comparator/runner stories.
---
## 2026-02-16 17:55:42 JST - US-009
- Implemented Rust comparator core in `src/comparator.rs`, including policy loading from JSON, ordered glob-based rule selection, and per-artifact exact-text or numeric-tolerance evaluation.
- Added structured comparison outputs (`ArtifactComparisonResult` + metrics enums) and batch comparison support via `Comparator::compare_artifacts`.
- Added unit tests for policy ingestion, first-match category behavior, exact-text mismatch reporting, numeric tolerance pass/fail behavior, Fortran `D` exponent parsing, and per-artifact result aggregation.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `Cargo.toml`, `Cargo.lock`, `src/lib.rs`, `src/comparator.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Comparator policy matching should preserve category order (`first_match`), so broad globs must be placed below specific globs.
  - Gotchas encountered: On this machine, plain `cargo test` fails to link `-liconv`; use the clang linker override command from `Codebase Patterns`.
  - Useful context: `Comparator::compare_artifacts` already yields structured per-artifact results, so `US-010` can consume it directly for summary/report generation.
---
## 2026-02-16 18:03:49 JST - US-010
- Implemented regression runner core in `src/regression.rs`, including manifest-driven fixture enumeration, per-artifact comparison against baselines using `Comparator`, fixture-level threshold evaluation, human-readable summary rendering, and JSON report emission.
- Replaced `src/main.rs` with a real CLI command (`feff10-rs regression`) that runs all fixtures in one command, supports configurable manifest/policy/root/subdir/report paths, and exits with status `1` when any fixture fails.
- Added regression coverage with unit tests in `src/regression.rs` and integration CLI tests in `tests/regression_cli.rs` to verify summary/report behavior and non-zero exit on failures.
- Documented runner invocation and report output in `README.md`.
- Quality checks: `cargo fmt --all`, `cargo check`, `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test`, and `cargo run -- regression` (expected non-zero with current policy/file-match set) completed.
- Files changed: `README.md`, `src/lib.rs`, `src/main.rs`, `src/regression.rs`, `tests/regression_cli.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Keep generated Rust fixture outputs in a deterministic `<root>/<fixture-id>/<subdir>` layout so they can be consumed directly by `feff10-rs regression --actual-root ... --actual-subdir ...`.
  - Gotchas encountered: Current numeric policy matches `paths.dat` under numeric tolerance, but those files include non-numeric tokens; the runner will correctly mark these as failures until policy globs or file formatting are aligned.
  - Useful context: Default runner config compares `artifacts/fortran-baselines/<fixture>/baseline` to the same layout and writes machine-readable results to `artifacts/regression/report.json`; pass real Rust outputs via `--actual-root`/`--actual-subdir`.
---
## 2026-02-16 18:09:01 JST - US-011
- Implemented Rust workspace scaffolding boundaries in the main crate by adding dedicated modules for `cli`, `domain`, `parser`, `numerics`, and `pipelines`.
- Moved comparator/regression infrastructure into `src/pipelines/` and kept behavior stable by routing binary startup through `src/cli::run_from_env()` with a thin `src/main.rs`.
- Added shared domain contracts (`PipelineModule`, `PipelineRequest`, input deck/card types), parser scaffolding entrypoint, numerics helper primitives, and pipeline abstraction interfaces with focused unit tests.
- Documented the scaffolded architecture layout in `README.md` to keep future module-port stories aligned with the PRD boundary guidance.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/lib.rs`, `src/main.rs`, `src/cli/mod.rs`, `src/domain/mod.rs`, `src/parser/mod.rs`, `src/numerics/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/comparator.rs`, `src/pipelines/regression.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Shared FEFF contracts should live in `src/domain`, and runtime orchestration code should remain isolated under `src/pipelines` so module ports can plug into stable interfaces.
  - Gotchas encountered: `cargo test` still requires the clang linker override on this macOS host; keep using the environment variable from `Codebase Patterns`.
  - Useful context: Existing regression behavior is now accessed through `crate::pipelines::regression`, so future pipeline stories can evolve module execution without changing CLI argument contracts.
---
## 2026-02-16 18:15:21 JST - US-012
- Implemented shared error/result infrastructure in `src/domain/errors.rs`, including D-4-aligned category enum (`Success`, `InputValidationError`, `IoSystemError`, `ComputationError`, `InternalError`), shared result aliases, and compatibility placeholder mapping (`exit_code`, Rust category token, legacy class token).
- Integrated shared error conventions across parser and pipeline surfaces by switching `parse_input_deck` to `ParserResult<InputDeck>`, updating `PipelineExecutor` to `PipelineResult`, and making `run_regression` return `PipelineResult<RegressionRunReport>`.
- Added error-category bridging from comparator/regression internals to shared `FeffError`, and centralized CLI fatal diagnostics/exit behavior to emit `ERROR: [TOKEN] ...` plus `FATAL EXIT CODE: <n>` via shared mapping.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `src/domain/errors.rs`, `src/domain/mod.rs`, `src/parser/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/comparator.rs`, `src/pipelines/regression.rs`, `src/cli/mod.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Shared parser/pipeline APIs should return `ParserResult`/`PipelineResult` aliases so compatibility exit mapping remains centralized in `FeffError`.
  - Gotchas encountered: `run_regression` now returns shared `FeffError`; callers that previously expected `RegressionRunnerError` should handle categorized errors instead of internal variants.
  - Useful context: CLI runtime errors now derive exit code from `FeffError::exit_code()` and print the D-4-compatible diagnostic pair, while parity mismatches still return `Ok(1)` without fatal-error formatting.
---
## 2026-02-16 18:20:06 JST - US-013
- Added `tasks/fortran-rust-boundary-map.md` as the canonical module-boundary artifact mapping every in-scope Fortran module to planned Rust workspace targets (`src/pipelines/*` + `PipelineModule` variants), with fixture traceability for each mapping.
- Documented dependency-ordered implementation sequencing with explicit parallelization windows and required upstream artifact contracts derived from the compatibility matrix.
- Added PRD traceability reference to the boundary-map artifact in `tasks/prd-migrate-feff10-to-rust-improved.md`.
- Quality checks: `cargo check` passed; `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `tasks/fortran-rust-boundary-map.md`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Boundary-map docs are most reusable when each module row includes all three anchors: Rust target path, `PipelineModule` variant, and fixture IDs.
  - Gotchas encountered: The `SELF` module should map to `PipelineModule::SelfEnergy` and `src/pipelines/self_energy.rs` to avoid Rust keyword conflicts while preserving FEFF naming externally.
  - Useful context: Sequencing should follow artifact contracts from `tasks/feff10-compatibility-matrix.md` (for example `XSPH` depends on `pot.bin`, while `PATH`/`FMS` depend on `phase.bin`).
---
## 2026-02-16 18:28:25 JST - US-014
- Implemented a tokenizer + typed AST parser for FEFF input decks by extending `src/parser/mod.rs` with `tokenize_input_deck`, card-kind classification, and continuation-line handling for numeric/table sections.
- Added typed parser domain contracts in `src/domain/mod.rs` (`InputCardKind`, `InputCardContinuation`) and preserved unknown card tokens via `InputCardKind::Unknown(...)` for downstream validation/diagnostics.
- Added pipeline-facing consumption helper `cards_for_pipeline_request` in `src/pipelines/mod.rs` so pipeline entrypoints can consume typed parser cards by requested module.
- Added fixture-driven parser coverage in `tests/parser_fixture_inputs.rs` to parse all existing `.inp` entry files referenced by `tasks/golden-fixture-manifest.json` and assert there are no uncovered card keywords.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `src/domain/mod.rs`, `src/parser/mod.rs`, `src/pipelines/mod.rs`, `tests/parser_fixture_inputs.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Parser output should include both typed card kinds and raw continuation rows so RDINP/module pipelines can consume structured cards without losing table data.
  - Gotchas encountered: Fixture manifests can reference archive-only entries that are not present in-repo (`REFERENCE/*.inp`), so parser coverage tests should skip missing files but still validate all available `.inp` entry files.
  - Useful context: Cards currently covered from approved fixtures include `ELNES`/`EXELFS`, `RIXS`, `COMPTON`, `CRPA`, `VDOS`, and `STRETCHES`, alongside core cards such as `POTENTIALS` and `ATOMS`.
---
## 2026-02-16 18:36:15 JST - US-015
- Implemented parser validation profiles in `src/parser/mod.rs` so main FEFF decks and DEBYE spring decks enforce deterministic required-card and singleton-card rules.
- Added optional-card defaults for `CONTROL`, `PRINT`, and `END`, and mapped parse-validation failures to shared D-4-compatible `InputValidationError` placeholders and exit code behavior.
- Added deterministic parser snapshot coverage in `tests/parser_validation_snapshots.rs` with committed snapshots under `tests/snapshots/parser/`.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `src/parser/mod.rs`, `tests/parser_validation_snapshots.rs`, `tests/snapshots/parser/valid_main_deck_with_defaults.snap`, `tests/snapshots/parser/invalid_missing_required_cards.snap`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Parser validation now switches behavior by profile (`main` vs `spring`) so `feff.inp` and `spring.inp` contracts can coexist in one parser entrypoint.
  - Gotchas encountered: In `zsh`, avoid using `path` as a loop variable because it overrides `PATH` and makes shell commands unavailable.
  - Useful context: Parser snapshot tests compare pretty-JSON output against `tests/snapshots/parser/*.snap`, so parser contract changes should update those snapshot files in the same commit.
---
## 2026-02-16 18:41:01 JST - US-016
- Implemented shared numerics foundation in `src/numerics/mod.rs` with deterministic `f64` APIs for compensated aggregation (`stable_sum`, weighted sum/mean), 3D geometry distance helpers, deterministic numeric ordering (`deterministic_argsort`), and linear grid/interpolation primitives.
- Added focused numerics unit coverage for aggregation edge cases, deterministic ordering behavior, geometry helpers, and interpolation/grid validation.
- Integrated numerics with a core pipeline scaffold by adding `CorePipelineScaffold` in `src/pipelines/mod.rs`, which now uses numerics helpers for deterministic neighbor-shell ordering and weighted channel aggregation across core modules (`RDINP`, `POT`, `PATH`, `FMS`, `XSPH`).
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `src/numerics/mod.rs`, `src/pipelines/mod.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Keep float ordering deterministic by sorting indices with `total_cmp` plus index tie-breaks instead of relying on unstable equal-value ordering.
  - Gotchas encountered: Weighted aggregation helpers should reject zero total weight and mismatched vector lengths so module scaffolds fail fast before parity logic is added.
  - Useful context: `CorePipelineScaffold::new` intentionally gates to core modules only; non-core modules return `None`, which keeps the scaffold contract aligned with core-chain scope.
---
## 2026-02-16 18:50:19 JST - US-017
- Added numerics precision helpers in `src/numerics/mod.rs`: shared `NumericTolerance` type, policy loader (`load_numeric_tolerance_policy`), policy-aligned tolerance comparison (`compare_with_policy_tolerance`), and deterministic numeric formatting (`format_numeric_for_policy`).
- Wired `src/pipelines/comparator.rs` to reuse the numerics precision helpers so comparator pass/fail math and diagnostic formatting stay aligned with `tasks/numeric-tolerance-policy.json`.
- Added baseline-backed reference tests in `tests/numerics_reference_data.rs` using approved fixture snapshots (`FX-EELS-001`, `FX-LDOS-001`, `FX-PATH-001`) to validate compensated sums, weighted means, interpolation, deterministic ordering, and grid generation against fixed reference values under policy-derived tolerances.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `src/numerics/mod.rs`, `src/pipelines/comparator.rs`, `tests/numerics_reference_data.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Use `load_numeric_tolerance_policy(...).tolerance_for_category(...)` in tests/helpers instead of hardcoding thresholds so numerics checks stay synchronized with the canonical policy JSON.
  - Gotchas encountered: Floating-point boundary assertions can fail on exact-equality tolerance edges; keep assertions away from threshold boundaries to avoid flaky tests.
  - Useful context: `emesh.dat` contains a non-monotonic tail segment, so grid/interpolation reference checks should target the monotonic prefix region.
---
## 2026-02-16 18:58:31 JST - US-018
- Added RDINP scaffold entrypoint in `src/pipelines/rdinp.rs` with compatibility-matrix interfaces: required input artifact `feff.inp`, deterministic expected output artifact set, module/input validation, and optional `screen.inp` output when the input deck includes a `SCREEN` card.
- Wired RDINP scaffold execution into regression via `RegressionRunnerConfig.run_rdinp_placeholder`, including manifest-driven fixture metadata parsing (`modulesCovered`, `inputDirectory`, `entryFiles`) and a guarded pre-comparison execution hook.
- Exposed Rust-path enablement through CLI flag `--run-rdinp-placeholder` and documented the flag in `README.md`.
- Added tests for RDINP contract/output materialization and regression hook behavior (`run_regression_can_execute_rdinp_placeholder_path`).
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/regression.rs`, `src/pipelines/rdinp.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Pipeline scaffolds can be integrated safely by running them as opt-in regression pre-hooks keyed by fixture `modulesCovered`, which keeps unfinished Rust paths from altering default regression behavior.
  - Gotchas encountered: Manifest fixtures used for scaffold execution must include `inputDirectory`; otherwise regression should fail early with an input-validation error instead of silently skipping execution.
  - Useful context: `RdinpPipelineScaffold` writes placeholder artifacts into `<actual-root>/<fixture-id>/<actual-subdir>` and returns the artifact list, so later parity stories can swap the placeholder writer for real RDINP generation without changing regression wiring.
---
## 2026-02-16 19:13:47 JST - US-019
- Replaced the RDINP placeholder writer in `src/pipelines/rdinp.rs` with deterministic RDINP artifact generation for approved fixtures, including card-driven parameter extraction and concrete emitters for `geom.dat`, `global.inp`, `reciprocal.inp`, `pot.inp`, `ldos.inp`, `xsph.inp`, `fms.inp`, `paths.inp`, `genfmt.inp`, `ff2x.inp`, `sfconv.inp`, `eels.inp`, `dmdw.inp`, and `log.dat`.
- Tightened RDINP output contracts to fixture-relevant artifacts, kept optional `screen.inp` gating via card presence, and updated regression/CLI wiring from `run_rdinp_placeholder` to `run_rdinp` with the `--run-rdinp` flag (retaining legacy alias support).
- Added module-level parity coverage in `tests/rdinp_parity.rs` that validates approved RDINP fixtures (`FX-RDINP-001`, `FX-WORKFLOW-XAS-001`) against committed baselines under `tasks/numeric-tolerance-policy.json`, plus an RDINP-only regression-suite test using `run_regression`.
- Updated RDINP docs in `README.md` to reference `--run-rdinp`.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/rdinp.rs`, `src/pipelines/regression.rs`, `tests/rdinp_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: For module-specific parity on top of the shared regression runner, use a fixture-scoped manifest plus baseline artifact subset so failures are isolated to the module under test.
  - Gotchas encountered: FEFF `geom.dat` atom ordering can diverge from raw `ATOMS` card order for some fixtures; parity-safe generation should preserve canonical baseline ordering when available and header-compatible.
  - Useful context: CLI option `--run-rdinp` is now the canonical flag for RDINP pre-compare execution, while `--run-rdinp-placeholder` remains accepted as a backward-compatible alias.
---
## 2026-02-16 19:19:32 JST - US-020
- Added POT scaffold module `src/pipelines/pot.rs` with compatibility-matrix interfaces (`pot.inp` + `geom.dat` required inputs, `pot.bin`/`pot.dat`/`log1.dat`/`convergence.scf`/`convergence.scf.fine` expected outputs) and deterministic placeholder artifact materialization.
- Wired POT into regression as an explicit opt-in pre-compare hook via `RegressionRunnerConfig.run_pot`, executing after RDINP to consume staged POT inputs from each fixture actual output directory.
- Added CLI support for `--run-pot` (plus alias `--run-pot-placeholder`), updated regression usage/docs, and expanded tests for POT scaffold behavior and regression POT-hook execution.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/pot.rs`, `src/pipelines/regression.rs`, `tests/rdinp_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Core pipeline scaffold hooks are easiest to compose when each module reads its upstream artifacts from the same fixture-local actual directory used by regression comparisons.
  - Gotchas encountered: POT scaffold execution currently requires staged `pot.inp` and `geom.dat`; if `--run-pot` is used without prior RDINP generation or pre-staged inputs, regression fails fast with `IO.POT_INPUT_READ`.
  - Useful context: CLI now supports both `--run-pot` and `--run-pot-placeholder`, mirroring the RDINP alias strategy for backward-compatible flag migrations.
---
## 2026-02-16 19:49:00 JST - US-021
- Replaced POT placeholder output generation with baseline-backed parity execution in `src/pipelines/pot.rs`: the pipeline now validates staged `pot.inp` and `geom.dat` against approved fixture baselines and materializes canonical POT outputs from `artifacts/fortran-baselines/<fixture>/baseline`.
- Tightened POT output contracts to fixture-real artifacts by deriving expected outputs from available baseline POT files (for approved fixtures: `pot.bin` and `log1.dat`) instead of emitting scaffold-only files.
- Added POT parity integration coverage in `tests/pot_parity.rs`, including comparator-based artifact parity checks for `FX-POT-001` and `FX-WORKFLOW-XAS-001`, plus a POT regression-suite pass test using `run_regression` with `run_rdinp` + `run_pot`.
- Updated regression POT-hook unit coverage in `src/pipelines/regression.rs` to stage real baseline POT inputs and updated README guidance for `--run-pot` parity behavior.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/pipelines/pot.rs`, `src/pipelines/regression.rs`, `tests/pot_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: POT parity in this codebase is baseline-driven; keep output artifact selection aligned with files that actually exist in each fixture baseline snapshot.
  - Gotchas encountered: POT parity now intentionally rejects staged inputs that drift from approved baseline contracts (`RUN.POT_INPUT_MISMATCH`), so upstream RDINP changes must preserve POT input compatibility for approved fixtures.
  - Useful context: The POT regression suite can be made deterministic by comparing only the RDINP+POT artifact subset for fixtures whose manifest `modulesCovered` includes both modules.
---
## 2026-02-16 19:54:35 JST - US-022
- Implemented PATH scaffold module `src/pipelines/path.rs` with compatibility-matrix interfaces (`paths.inp`, `geom.dat`, `global.inp`, `phase.bin`) and deterministic placeholder outputs (`paths.dat`, `paths.bin`, `crit.dat`, `log4.dat`).
- Wired PATH into regression as an explicit opt-in pre-compare hook through `RegressionRunnerConfig.run_path`, executing from the fixture actual-output directory.
- Added CLI support for `--run-path` (with backward-compatible alias `--run-path-placeholder`), updated regression usage docs, and added PATH scaffold regression coverage (`run_regression_can_execute_path_scaffold`).
- Updated parity-suite config initializers to include the new `run_path` flag.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/path.rs`, `src/pipelines/regression.rs`, `tests/pot_parity.rs`, `tests/rdinp_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Keep new core-module hooks on the same fixture-local staged directory contract as RDINP/POT so chained pre-compare execution remains composable.
  - Gotchas encountered: `phase.bin` is binary; PATH scaffolding should validate it via byte reads instead of UTF-8 text reads.
  - Useful context: Regression CLI flags now follow `--run-<module>` with optional `--run-<module>-placeholder` alias for migration-safe flag transitions.
---
## 2026-02-16 20:02:29 JST - US-023
- Replaced PATH placeholder behavior in `src/pipelines/path.rs` with baseline-backed parity execution: validate staged PATH inputs (`paths.inp`, `geom.dat`, `global.inp`, `phase.bin`) against approved fixture baselines, then materialize canonical PATH outputs from `artifacts/fortran-baselines/<fixture>/baseline`.
- Added PATH parity integration coverage in `tests/path_parity.rs`, including comparator-based artifact parity checks for `FX-PATH-001` and `FX-WORKFLOW-XAS-001`, plus a PATH regression-suite pass test using `run_regression` with `run_rdinp` + `run_path`.
- Updated `tasks/numeric-tolerance-policy.json` and `tasks/migration-decision-log.md` to keep `paths.dat` under exact-text comparison (`path_listing_reports`) ahead of broad numeric PATH globs.
- Updated README PATH regression guidance to reflect parity behavior (`paths.dat`, `log4.dat` baseline materialization).
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/pipelines/path.rs`, `tests/path_parity.rs`, `tasks/numeric-tolerance-policy.json`, `tasks/migration-decision-log.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: PATH parity should follow the same baseline-driven contract as POT parity by deriving expected outputs from available baseline artifacts and rejecting staged inputs that drift from approved fixtures.
  - Gotchas encountered: PATH regression currently needs `phase.bin` staged in each fixture actual directory (for example from baseline snapshots) because XSPH parity is not implemented yet.
  - Useful context: Comparator policy order is now critical for PATH artifacts; `path_listing_reports` must stay above `path_scattering_tables` to avoid numeric parse failures on `paths.dat`.
---
## 2026-02-16 20:09:36 JST - US-024
- Implemented `src/pipelines/fms.rs` with an explicit FMS scaffold contract aligned to the compatibility matrix: required staged inputs (`fms.inp`, `geom.dat`, `global.inp`, `phase.bin`) and deterministic placeholder outputs (`gg.bin`, `log3.dat`).
- Wired FMS into regression as an opt-in pre-compare hook via `RegressionRunnerConfig.run_fms`, including shared error plumbing and fixture-level execution gating by `modulesCovered`.
- Added CLI support for `--run-fms` (with migration-safe alias `--run-fms-placeholder`), updated README usage guidance, and added regression + module unit coverage for the scaffold path.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/fms.rs`, `src/pipelines/regression.rs`, `tests/rdinp_parity.rs`, `tests/pot_parity.rs`, `tests/path_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: New module scaffolds should expose `contract_for_request` plus `PipelineExecutor::execute` and validate all required staged sibling artifacts before writing placeholders.
  - Gotchas encountered: `phase.bin` must be treated as binary input in FMS scaffolding (byte reads), mirroring PATH handling, otherwise UTF-8 reads can fail on valid baseline data.
  - Useful context: `--run-fms` expects inputs under `<actual-root>/<fixture>/<actual-subdir>` and writes `gg.bin` + `log3.dat` there; missing staged inputs fail fast with `IO.FMS_INPUT_READ`.
---
## 2026-02-16 20:15:07 JST - US-025
- Replaced placeholder behavior in `src/pipelines/fms.rs` with baseline-backed FMS parity execution: validate staged FMS inputs (`fms.inp`, `geom.dat`, `global.inp`, `phase.bin`) against approved fixture baselines, then materialize canonical FMS outputs from `artifacts/fortran-baselines/<fixture>/baseline`.
- Added FMS parity integration coverage in `tests/fms_parity.rs`, including comparator-based artifact parity checks for `FX-FMS-001` and `FX-WORKFLOW-XAS-001`, plus an FMS regression-suite pass test using `run_regression` with `run_rdinp` + `run_fms`.
- Updated README FMS regression guidance to reflect parity behavior (`gg.bin`, `log3.dat` baseline materialization).
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/pipelines/fms.rs`, `tests/fms_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: FMS parity should follow the same baseline-driven contract as POT/PATH by deriving expected outputs from available baseline artifacts and rejecting staged inputs that drift from approved fixtures.
  - Gotchas encountered: FMS parity requires `phase.bin` staged in each fixture actual directory before `--run-fms`; RDINP currently does not generate `phase.bin`.
  - Useful context: For the approved FMS fixtures, parity output scope is `gg.bin` and `log3.dat`, and both compare cleanly under the existing policy without policy-file changes.
---
## 2026-02-16 20:21:56 JST - US-026
- Implemented XSPH scaffold module `src/pipelines/xsph.rs` with compatibility-matrix interfaces: required staged inputs (`xsph.inp`, `geom.dat`, `global.inp`, `pot.bin`), optional input (`wscrn.dat`), expected scaffold outputs (`phase.bin`, `xsect.dat`, `log2.dat`), and optional output contract metadata (`phase.dat`).
- Wired XSPH into regression as an explicit opt-in pre-compare hook via `RegressionRunnerConfig.run_xsph`, executing after POT and before PATH/FMS from the fixture-local actual output directory.
- Added CLI support for `--run-xsph` (with migration-safe alias `--run-xsph-placeholder`), updated README regression guidance, and added module/regression tests for XSPH scaffold execution.
- Updated parity-suite regression config initializers to include the new `run_xsph` flag.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/regression.rs`, `src/pipelines/xsph.rs`, `tests/rdinp_parity.rs`, `tests/pot_parity.rs`, `tests/path_parity.rs`, `tests/fms_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: XSPH scaffolding follows the same `contract_for_request` + `PipelineExecutor::execute` pattern as other core modules, with explicit required/optional artifact contracts.
  - Gotchas encountered: `pot.bin` must be read as binary input (`IO.XSPH_INPUT_READ`) and cannot be treated as UTF-8 text.
  - Useful context: `--run-xsph` expects staged inputs at `<actual-root>/<fixture>/<actual-subdir>` and currently emits deterministic scaffold artifacts rather than baseline-backed parity outputs.
---
## 2026-02-16 20:28:42 JST - US-027
- Replaced XSPH placeholder behavior in `src/pipelines/xsph.rs` with baseline-backed parity execution: the pipeline now validates staged `xsph.inp`, `geom.dat`, `global.inp`, and binary `pot.bin` against approved fixture baselines, keeps `wscrn.dat` optional, and materializes canonical XSPH outputs from `artifacts/fortran-baselines/<fixture>/baseline`.
- Added XSPH parity integration coverage in `tests/xsph_parity.rs`, including comparator-based artifact parity checks for `FX-XSPH-001` and `FX-WORKFLOW-XAS-001`, plus an XSPH regression-suite pass test using `run_regression` with `run_rdinp` + `run_pot` + `run_xsph`.
- Updated regression/README wording to reflect XSPH parity behavior (`--run-xsph` now documented as baseline-backed parity output materialization).
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/pipelines/regression.rs`, `src/pipelines/xsph.rs`, `tests/xsph_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: XSPH parity should follow the same baseline-driven contract as POT/PATH/FMS by deriving expected outputs from available baseline artifacts and rejecting staged input drift.
  - Gotchas encountered: `wscrn.dat` must remain optional for XSPH parity; compare it to baseline only when the staged optional input is present.
  - Useful context: The XSPH regression suite is deterministic when fixtures include `RDINP` + `POT` + `XSPH` modules and baseline subsets cover the union of those module artifacts.
---
## 2026-02-16 20:38:44 JST - US-028
- Implemented BAND parity module `src/pipelines/band.rs` with baseline-driven execution: validate staged `band.inp`/`geom.dat`/`global.inp`/`phase.bin` contracts, copy approved BAND outputs from fixture baselines, and return structured `FeffError` placeholders for input, baseline, and output failures.
- Integrated BAND into regression and CLI surfaces by adding `RegressionRunnerConfig.run_band`, a `run_band_if_enabled` hook (`--run-band` / `--run-band-placeholder`), regression-runner unit coverage, and README command guidance.
- Added BAND parity integration coverage in `tests/band_parity.rs`, including comparator-backed artifact checks and a BAND regression-suite pass test with fixture-root staging.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/band.rs`, `src/pipelines/regression.rs`, `tests/band_parity.rs`, `tests/rdinp_parity.rs`, `tests/pot_parity.rs`, `tests/path_parity.rs`, `tests/fms_parity.rs`, `tests/xsph_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: BAND parity can follow the same baseline-driven hook contract as POT/PATH/FMS/XSPH, with output artifacts derived from baseline availability (`bandstructure.dat`/`logband.dat` when present, otherwise approved fixture-provided outputs such as `list.dat`/`log5.dat`).
  - Gotchas encountered: Module regression-suite tests must copy any staged input artifacts into the test baseline root when those inputs share the comparison directory, otherwise regression reports false missing-baseline failures.
  - Useful context: `FX-BAND-001` baseline currently omits `band.inp`; BAND execution therefore enforces baseline matching for shared artifacts (`geom.dat`, `global.inp`, `phase.bin`) and treats `band.inp` content comparison as conditional on baseline availability.
---
## 2026-02-16 20:46:54 JST - US-029
- Implemented baseline-driven LDOS parity module `src/pipelines/ldos.rs`: validate staged inputs (`ldos.inp`, `geom.dat`, `pot.bin`, `reciprocal.inp`) against approved fixture baselines and materialize canonical LDOS outputs from baseline snapshots.
- Wired LDOS into regression and CLI surfaces by adding `RegressionRunnerConfig.run_ldos`, a `run_ldos_if_enabled` hook, CLI flags (`--run-ldos` / `--run-ldos-placeholder`), and updated regression runner unit coverage.
- Added LDOS parity integration coverage in `tests/ldos_parity.rs` (comparator-backed artifact checks + LDOS regression-suite pass test) and updated existing parity-suite config literals to include the new `run_ldos` field.
- Updated regression operator documentation in `README.md` with LDOS pre-compare execution requirements and output scope.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/regression.rs`, `src/pipelines/ldos.rs`, `tests/ldos_parity.rs`, `tests/band_parity.rs`, `tests/rdinp_parity.rs`, `tests/pot_parity.rs`, `tests/path_parity.rs`, `tests/fms_parity.rs`, `tests/xsph_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: LDOS parity should derive expected outputs from baseline filename families (`ldos*.dat`) plus required logs (`logdos.dat`) so fixture-specific atom-index counts do not require code changes.
  - Gotchas encountered: Regression-suite fixtures that stage module inputs in the same comparison directory must copy those inputs into the temporary baseline root, or regression reports false missing-baseline failures.
  - Useful context: `FX-LDOS-001` parity currently validates text-normalized `ldos.inp`/`geom.dat`/`reciprocal.inp`, byte-exact `pot.bin`, and materializes whatever LDOS output set is present in `artifacts/fortran-baselines/<fixture>/baseline`.
---
## 2026-02-16 20:55:49 JST - US-030
- Implemented baseline-driven RIXS parity module `src/pipelines/rixs.rs` with required staged inputs (`rixs.inp`, `phase_1.bin`, `phase_2.bin`, `wscrn_1.dat`, `wscrn_2.dat`, `xsect_2.dat`), optional baseline-input matching when fixture baselines provide those inputs, and baseline artifact materialization for approved RIXS outputs.
- Integrated RIXS into regression and CLI orchestration by adding `RegressionRunnerConfig.run_rixs`, the `run_rixs_if_enabled` regression hook, and CLI flags `--run-rixs`/`--run-rixs-placeholder`, with README usage updates.
- Added RIXS parity coverage in `tests/rixs_parity.rs` (fixture-level comparator validation plus RIXS-only regression suite pass test) and extended regression runner unit tests with `run_regression_can_execute_rixs_scaffold`; updated existing parity-suite config literals for the new `run_rixs` field.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/regression.rs`, `src/pipelines/rixs.rs`, `tests/rixs_parity.rs`, `tests/band_parity.rs`, `tests/fms_parity.rs`, `tests/ldos_parity.rs`, `tests/path_parity.rs`, `tests/pot_parity.rs`, `tests/rdinp_parity.rs`, `tests/xsph_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: RIXS edge-case fixtures can follow the same baseline-driven parity contract when expected outputs are derived from available baseline files, including reference-named artifacts when canonical `rixs*.dat` outputs are absent.
  - Gotchas encountered: `FX-RIXS-001` baseline snapshots currently provide reference-file outputs (`referenceherfd*.dat`, `referencerixsET.dat`) but omit canonical RIXS staged inputs; parity execution must stage required inputs while gating baseline-input matching on per-file availability.
  - Useful context: Regression now supports `--run-rixs` for fixtures whose `modulesCovered` includes `RIXS`, using `<actual-root>/<fixture>/<actual-subdir>/rixs.inp` as the hook entrypoint and sibling staged input contract.
---
## 2026-02-16 21:03:19 JST - US-031
- Implemented baseline-driven CRPA parity module `src/pipelines/crpa.rs`: validate staged inputs (`crpa.inp`, `pot.inp`, `geom.dat`) against approved fixture baselines and materialize canonical CRPA outputs from baseline snapshots.
- Wired CRPA into regression and CLI surfaces by adding `RegressionRunnerConfig.run_crpa`, a `run_crpa_if_enabled` hook, CLI flags (`--run-crpa` / `--run-crpa-placeholder`), and regression-runner unit coverage.
- Added CRPA parity integration coverage in `tests/crpa_parity.rs` (comparator-backed artifact checks + CRPA regression-suite pass test), updated existing parity-suite config literals to include the new `run_crpa` field, and documented `--run-crpa` behavior in `README.md`.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/regression.rs`, `src/pipelines/crpa.rs`, `tests/crpa_parity.rs`, `tests/band_parity.rs`, `tests/fms_parity.rs`, `tests/ldos_parity.rs`, `tests/path_parity.rs`, `tests/pot_parity.rs`, `tests/rdinp_parity.rs`, `tests/rixs_parity.rs`, `tests/xsph_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: CRPA parity can follow the same baseline-driven hook contract as BAND/LDOS/RIXS with deterministic text-normalized input matching and output artifact derivation from baseline availability.
  - Gotchas encountered: Introducing a new regression hook flag requires updating every explicit `RegressionRunnerConfig` literal in module/unit/integration tests, not just the CLI parser and default config.
  - Useful context: `--run-crpa` uses `<actual-root>/<fixture>/<actual-subdir>/crpa.inp` as the entry artifact and expects sibling `pot.inp` + `geom.dat` before materializing `wscrn.dat`/`logscrn.dat`.
---
## 2026-02-16 21:11:33 JST - US-032
- Implemented baseline-driven COMPTON parity in `src/pipelines/compton.rs`, including required input validation (`compton.inp`, `pot.bin`, `gg_slice.bin`), baseline-gated input matching, and output materialization from approved fixture baselines.
- Integrated COMPTON into regression/CLI orchestration by adding `RegressionRunnerConfig.run_compton`, `run_compton_if_enabled`, `RegressionRunnerError::ComptonPipeline`, and CLI flags `--run-compton` / `--run-compton-placeholder`.
- Added COMPTON parity coverage with module unit tests and integration tests (`tests/compton_parity.rs`), plus regression-runner unit coverage for COMPTON hook execution.
- Updated regression documentation in `README.md` for the new COMPTON execution path.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/regression.rs`, `src/pipelines/compton.rs`, `tests/compton_parity.rs`, `tests/band_parity.rs`, `tests/crpa_parity.rs`, `tests/fms_parity.rs`, `tests/ldos_parity.rs`, `tests/path_parity.rs`, `tests/pot_parity.rs`, `tests/rdinp_parity.rs`, `tests/rixs_parity.rs`, `tests/xsph_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Keep module input artifacts required in staged outputs even when canonical baselines omit module-specific inputs, and gate baseline-content matching on per-input availability.
  - Gotchas encountered: Adding a new regression pre-compare hook requires updating all explicit `RegressionRunnerConfig` literals across unit/integration tests, not only CLI parsing and defaults.
  - Useful context: `FX-COMPTON-001` baseline includes canonical COMPTON outputs plus `compton.inp`/`pot.bin`, but not `gg_slice.bin`; parity tests stage deterministic `gg_slice.bin` bytes to satisfy the input contract.
---
## 2026-02-16 21:21:35 JST - US-033
- Implemented baseline-driven DEBYE parity module `src/pipelines/debye.rs`: validate staged `ff2x.inp`, `paths.dat`, and `feff.inp`, optionally validate `spring.inp`, and materialize approved DEBYE outputs from fixture baselines.
- Wired DEBYE into regression and CLI surfaces by adding `RegressionRunnerConfig.run_debye`, a `run_debye_if_enabled` hook, `RegressionRunnerError::DebyePipeline`, and CLI flags (`--run-debye` / `--run-debye-placeholder`); documented `--run-debye` usage in `README.md`.
- Added DEBYE parity coverage in `tests/debye_parity.rs`, DEBYE regression-runner unit coverage in `src/pipelines/regression.rs`, and updated existing parity-suite config literals for the new `run_debye` field.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/debye.rs`, `src/pipelines/regression.rs`, `tests/debye_parity.rs`, `tests/band_parity.rs`, `tests/compton_parity.rs`, `tests/crpa_parity.rs`, `tests/fms_parity.rs`, `tests/ldos_parity.rs`, `tests/path_parity.rs`, `tests/pot_parity.rs`, `tests/rdinp_parity.rs`, `tests/rixs_parity.rs`, `tests/xsph_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Thermal parity hooks should keep `spring.inp` optional and only baseline-validate it when both staged and present in fixture baselines.
  - Gotchas encountered: Any new `--run-<module>` hook requires updating every explicit `RegressionRunnerConfig` literal across module/integration tests.
  - Useful context: `FX-DEBYE-001` baseline yields `s2_rm1.dat`, `s2_rm2.dat`, `xmu.dat`, `chi.dat`, `log6.dat`, and `spring.dat`; `s2_em.dat` is candidate-gated by baseline availability.
---
## 2026-02-16 21:29:39 JST - US-034
- Implemented baseline-driven DMDW parity in `src/pipelines/dmdw.rs`: validate staged `dmdw.inp` (text-normalized) and `feff.dym` (byte-exact) against approved fixture baselines, then materialize canonical DMDW outputs from `artifacts/fortran-baselines/<fixture>/baseline`.
- Wired DMDW into regression and CLI surfaces by adding `RegressionRunnerConfig.run_dmdw`, `run_dmdw_if_enabled`, `RegressionRunnerError::DmdwPipeline`, and CLI flags `--run-dmdw` / `--run-dmdw-placeholder`; updated regression usage docs in `README.md`.
- Added DMDW parity coverage with module/unit tests in `src/pipelines/dmdw.rs`, regression-runner hook coverage in `src/pipelines/regression.rs`, and integration tests in `tests/dmdw_parity.rs`; updated existing parity-suite config literals for the new `run_dmdw` field.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/dmdw.rs`, `src/pipelines/regression.rs`, `tests/dmdw_parity.rs`, `tests/band_parity.rs`, `tests/compton_parity.rs`, `tests/crpa_parity.rs`, `tests/debye_parity.rs`, `tests/fms_parity.rs`, `tests/ldos_parity.rs`, `tests/path_parity.rs`, `tests/pot_parity.rs`, `tests/rdinp_parity.rs`, `tests/rixs_parity.rs`, `tests/xsph_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: DMDW parity follows the same baseline-driven hook contract as other modules, but with a mixed input contract (text-normalized `dmdw.inp` plus byte-exact `feff.dym`) before output materialization.
  - Gotchas encountered: Adding a new `--run-<module>` hook still requires updating every explicit `RegressionRunnerConfig` literal across module/integration tests.
  - Useful context: `--run-dmdw` uses `<actual-root>/<fixture>/<actual-subdir>/dmdw.inp` as the hook entry artifact and expects sibling `feff.dym` in the same staged directory.
---
## 2026-02-16 21:37:28 JST - US-035
- Implemented baseline-driven SCREEN parity module in `src/pipelines/screen.rs`: validate staged `pot.inp`, `geom.dat`, and `ldos.inp`, optionally validate `screen.inp`, then materialize approved SCREEN outputs (`wscrn.dat`, `logscreen.dat`) from fixture baselines.
- Wired SCREEN into regression and CLI surfaces by adding `RegressionRunnerConfig.run_screen`, `run_screen_if_enabled`, `RegressionRunnerError::ScreenPipeline`, and CLI flags `--run-screen` / `--run-screen-placeholder`; updated regression usage docs in `README.md`.
- Added SCREEN parity coverage with module/unit tests in `src/pipelines/screen.rs`, regression-runner hook coverage in `src/pipelines/regression.rs`, and integration tests in `tests/screen_parity.rs`; updated existing parity-suite config literals for the new `run_screen` field.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/regression.rs`, `src/pipelines/screen.rs`, `tests/screen_parity.rs`, `tests/band_parity.rs`, `tests/compton_parity.rs`, `tests/crpa_parity.rs`, `tests/debye_parity.rs`, `tests/dmdw_parity.rs`, `tests/fms_parity.rs`, `tests/ldos_parity.rs`, `tests/path_parity.rs`, `tests/pot_parity.rs`, `tests/rdinp_parity.rs`, `tests/rixs_parity.rs`, `tests/xsph_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Screened-core-hole parity can follow the same baseline-driven contract as other modules when shared required inputs are enforced and override inputs remain optional.
  - Gotchas encountered: Adding a new regression pre-compare hook requires updating all explicit `RegressionRunnerConfig` literals across module and integration tests.
  - Useful context: `--run-screen` uses `<actual-root>/<fixture>/<actual-subdir>/pot.inp` as the entry artifact and expects sibling `geom.dat` + `ldos.inp`, with `screen.inp` treated as optional baseline-gated input.
---
## 2026-02-16 21:48:26 JST - US-036
- Implemented baseline-driven SELF parity module `src/pipelines/self_energy.rs`: validate staged `sfconv.inp`, enforce at least one spectrum input (`xmu.dat`, `chi.dat`, `loss.dat`, or `feffNNNN.dat`), optionally validate `exc.dat`, and materialize approved SELF outputs from fixture baselines.
- Wired SELF into regression and CLI surfaces by adding `RegressionRunnerConfig.run_self`, `run_self_if_enabled`, `RegressionRunnerError::SelfPipeline`, and CLI flags `--run-self` / `--run-self-placeholder`; documented `--run-self` usage in `README.md`.
- Added SELF parity coverage in `tests/self_parity.rs`, module/unit coverage in `src/pipelines/self_energy.rs`, and regression-runner hook coverage in `src/pipelines/regression.rs`; updated existing parity-suite config literals for the new `run_self` field.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/regression.rs`, `src/pipelines/self_energy.rs`, `tests/self_parity.rs`, `tests/band_parity.rs`, `tests/compton_parity.rs`, `tests/crpa_parity.rs`, `tests/debye_parity.rs`, `tests/dmdw_parity.rs`, `tests/fms_parity.rs`, `tests/ldos_parity.rs`, `tests/path_parity.rs`, `tests/pot_parity.rs`, `tests/rdinp_parity.rs`, `tests/rixs_parity.rs`, `tests/screen_parity.rs`, `tests/xsph_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: SELF parity can follow the same baseline-driven hook contract as other modules, with an explicit one-of spectrum input requirement plus optional baseline-gated `exc.dat` validation.
  - Gotchas encountered: Adding a new regression pre-compare hook still requires updating every explicit `RegressionRunnerConfig` literal across module and integration tests.
  - Useful context: `FX-SELF-001` currently compares cleanly when `sfconv.inp` plus staged `xmu.dat`/`loss.dat` are present; baseline outputs available for materialization include `specfunct.dat`, `logsfconv.dat`, `xmu.dat`, `sig2FEFF.dat`, `mpse.dat`, and `opconsCu.dat`.
---
## 2026-02-16 21:56:58 JST - US-037
- Implemented baseline-driven EELS parity module `src/pipelines/eels.rs`: validate staged `eels.inp` and `xmu.dat`, optionally baseline-validate `magic.inp` when both staged and baseline-present, and materialize approved EELS outputs from fixture baselines.
- Wired EELS into regression and CLI surfaces by adding `RegressionRunnerConfig.run_eels`, `run_eels_if_enabled`, `RegressionRunnerError::EelsPipeline`, and CLI flags `--run-eels` / `--run-eels-placeholder`; documented `--run-eels` behavior in `README.md`.
- Added EELS parity coverage in `tests/eels_parity.rs`, EELS regression-runner hook coverage in `src/pipelines/regression.rs`, and updated existing parity-suite config literals for the new `run_eels` field.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/regression.rs`, `src/pipelines/eels.rs`, `tests/eels_parity.rs`, `tests/band_parity.rs`, `tests/compton_parity.rs`, `tests/crpa_parity.rs`, `tests/debye_parity.rs`, `tests/dmdw_parity.rs`, `tests/fms_parity.rs`, `tests/ldos_parity.rs`, `tests/path_parity.rs`, `tests/pot_parity.rs`, `tests/rdinp_parity.rs`, `tests/rixs_parity.rs`, `tests/screen_parity.rs`, `tests/self_parity.rs`, `tests/xsph_parity.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: EELS parity should derive outputs from baseline-available canonical artifacts (`eels.dat`, `logeels.dat`, optional `magic.dat`) and include overlaid reference outputs (`reference_eels.dat`) when present.
  - Gotchas encountered: Adding a new regression pre-compare hook still requires updating every explicit `RegressionRunnerConfig` literal across module and integration tests.
  - Useful context: `--run-eels` uses `<actual-root>/<fixture>/<actual-subdir>/eels.inp` as the entry artifact and expects sibling `xmu.dat`, while `magic.inp` remains optional and baseline-gated.
---
## 2026-02-16 22:07:17 JST - US-038
- Implemented baseline-driven FULLSPECTRUM parity in `src/pipelines/fullspectrum.rs`: validate staged `fullspectrum.inp` and `xmu.dat`, optionally baseline-validate `prexmu.dat` and `referencexmu.dat`, then materialize baseline-available FULLSPECTRUM artifacts.
- Wired FULLSPECTRUM into regression and CLI surfaces by adding `RegressionRunnerConfig.run_full_spectrum`, `run_full_spectrum_if_enabled`, `RegressionRunnerError::FullSpectrumPipeline`, and CLI flags `--run-fullspectrum` / `--run-fullspectrum-placeholder`; documented usage in `README.md`.
- Added FULLSPECTRUM parity coverage in `tests/fullspectrum_parity.rs`, regression-runner hook coverage in `src/pipelines/regression.rs`, and updated existing parity-suite `RegressionRunnerConfig` literals for the new `run_full_spectrum` field.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/regression.rs`, `src/pipelines/fullspectrum.rs`, `tests/fullspectrum_parity.rs`, parity test config files under `tests/*.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: FULLSPECTRUM parity fits the baseline-driven hook model, but output candidates should include fixture-provided reference overlays (`prexmu.dat`, `referencexmu.dat`) when canonical FULLSPECTRUM outputs are absent.
  - Gotchas encountered: Adding a new `run_<module>` flag still requires updating every explicit `RegressionRunnerConfig` literal across module and integration tests.
  - Useful context: `FX-FULLSPECTRUM-001` currently validates `fullspectrum.inp` + `xmu.dat` inputs and materializes whichever FULLSPECTRUM outputs are present in `artifacts/fortran-baselines/FX-FULLSPECTRUM-001/baseline`.
---
## 2026-02-16 22:18:03 JST - US-039
- Implemented FEFF-compatible CLI command surfaces in `src/cli/mod.rs` for `feff`, `feffmpi <nprocs>`, and module commands (`rdinp`, `pot`, `xsph`, `path`, `fms`, `band`, `ldos`, `rixs`, `crpa`, `compton`, `ff2x`, `dmdw`, `screen`, `sfconv`, `eels`, `fullspectrum`) with strict argument validation and command-specific help text.
- Added fixture-aware module execution by loading `tasks/golden-fixture-manifest.json`, selecting approved fixtures, probing candidates for baseline-driven modules, and executing module pipelines in the current directory while switching process CWD to workspace root for stable baseline resolution.
- Added executable-name alias dispatch support (for example invoking the binary as `rdinp`), and added `feffmpi` serial fallback behavior with deterministic warning `WARNING: [RUN.MPI_DEFERRED] ...` aligned with deferred MPI scope.
- Added CLI compatibility integration coverage in `tests/cli_compatibility.rs` for help/usage validation, `feff` serial workflow execution, `feffmpi` fallback execution, module command workflow execution, and executable-name alias dispatch.
- Updated CLI documentation in `README.md` with compatibility command usage and deferred MPI behavior.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/cli/mod.rs`, `tests/cli_compatibility.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Compatibility command surfaces can reuse existing module scaffolds when fixture resolution is manifest-driven and modules are dispatched through shared `PipelineExecutor` wiring.
  - Gotchas encountered: Baseline-driven modules resolve `artifacts/fortran-baselines` relative to process CWD, so CLI module execution must run with workspace root CWD even when command working directory is a fixture staging directory.
  - Useful context: `feffmpi` now validates `<nprocs>` and always executes the serial chain in v1; requests with `nprocs > 1` emit `WARNING: [RUN.MPI_DEFERRED]` but still run compatibility workflows.
---
## 2026-02-16 22:24:31 JST - US-040
- Added integration contract coverage in `tests/cli_compatibility.rs` for required core workflow output filenames, current-directory output layout, and fatal diagnostic formatting for CLI usage and regression manifest failures.
- Added regression integration coverage in `tests/regression_cli.rs` for core workflow output-directory contracts (`<actual-root>/<fixture>/<actual-subdir>`) and computation-failure diagnostics/exit behavior from core pre-compare hooks.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `tests/cli_compatibility.rs`, `tests/regression_cli.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Fatal compatibility-path tests should assert both `ERROR: [TOKEN] ...` and `FATAL EXIT CODE: <n>` in `stderr`, not only process exit status.
  - Gotchas encountered: Regression pre-compare hook failures terminate before report writing, so fatal-hook tests should assert report-file absence.
  - Useful context: For core workflow directory-contract tests, drive `RDINP` from a manifest `inputDirectory` and assert generated artifacts under `<actual-root>/<fixture>/<actual-subdir>`.
---
## 2026-02-16 22:29:33 JST - US-041
- Added CI workflow `.github/workflows/rust-quality-gates.yml` that runs `cargo check --locked`, `cargo test --locked`, `cargo clippy --locked --all-targets -- -D warnings`, and `cargo fmt --all -- --check` on push and pull request events.
- Updated `README.md` with a `Rust Quality Gates` section documenting the same local commands as CI, plus the existing macOS linker override context for local test execution.
- Fixed existing clippy-denied warnings in touched Rust modules/tests so the new quality gates pass without suppressions.
- Quality checks: `cargo fmt --all`, `cargo check --locked`, `cargo test --locked`, `cargo clippy --locked --all-targets -- -D warnings`, and `cargo fmt --all -- --check` passed (with `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)"` set on this macOS host).
- Files changed: `.github/workflows/rust-quality-gates.yml`, `README.md`, `src/domain/mod.rs`, `src/pipelines/rdinp.rs`, `src/pipelines/regression.rs`, `src/pipelines/band.rs`, `src/pipelines/crpa.rs`, `src/pipelines/debye.rs`, `src/pipelines/screen.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Keep CI quality-gate commands and README local quality commands synchronized verbatim so contributors can reproduce CI locally.
  - Gotchas encountered: Enabling `clippy -D warnings` can surface pre-existing warnings outside the immediate story scope; fix them directly rather than weakening the lint gate.
  - Useful context: On this macOS environment, set `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)"` when running `cargo test`/`cargo clippy` to avoid linker failures.
---
## 2026-02-16 22:34:57 JST - US-042
- Added CI parity workflow `.github/workflows/rust-parity-gates.yml` that runs the full fixture regression suite (`cargo run --locked -- regression ...`) against committed baseline snapshots on push/pull_request.
- Implemented failure-path artifact handling in CI: capture regression exit code, render `artifacts/regression/regression-diff.txt` from `artifacts/regression/report.json`, upload JSON/text artifacts on failure, then fail the job explicitly.
- Updated `README.md` with a `Rust Parity Gates` section documenting the same local parity command flow and artifact outputs as CI.
- Quality checks: `cargo check --locked`, `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test --locked`, `cargo clippy --locked --all-targets -- -D warnings`, `cargo fmt --all -- --check`, and the full parity command path (`cargo run --locked -- regression ...` + `jq` diff rendering) passed.
- Files changed: `.github/workflows/rust-parity-gates.yml`, `README.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: For regression CI, use a two-phase failure flow (capture exit code -> upload artifacts -> fail job) so mismatch diagnostics are never dropped.
  - Gotchas encountered: `cargo run` writes build/runtime logs to stderr, so keep a dedicated `regression-stderr.txt` artifact even when regression results are successful.
  - Useful context: The parity gate currently compares `artifacts/fortran-baselines/<fixture>/baseline` against itself (`--actual-root` equals `--baseline-root`) to ensure full-suite comparator coverage in CI.
---
