# Ralph Progress Log
Started: Tue Feb 17 21:53:52 JST 2026

## Codebase Patterns
- Add shared third-party dependencies in workspace `Cargo.toml` and consume them in crates with `<dependency>.workspace = true`.
- For new numerics domains, add `pub mod <domain>;` to `crates/feff-core/src/numerics/mod.rs` and re-export public APIs from `crates/feff-core/src/numerics/<domain>/mod.rs`.
- FEFF special-function parity ports should mirror `besjh.f90` region cutoffs (`Re/|Im| < 1.0`, `< 7.51`) and use targeted `bjnser` seeding plus recursion per region.
- FEFF Hankel parity follows `besjh.f90` conventions: use `hl = -nl + i*jl` in small/mid regions, and in the asymptotic branch select `exp(±i z)` plus `sjl ± i*cjl` based on the sign of `Im(z)`.
- Spherical harmonics ports should use the Condon-Shortley convention with `Y_l^{-m} = (-1)^m * conj(Y_l^m)`, and regression tests should include the sum rule `sum_m |Y_lm|^2 = (2l+1)/(4*pi)`.
- FEFF `cwig3j` ports must preserve its 1-indexed log-factorial table semantics (`al(i) = ln((i-1)!)`); treating it as `ln(i!)` introduces normalization/sign drift.
- Wigner 6j ports should use Racah summation on doubled quantum numbers with triangle tuples `(j1,j2,j3)`, `(j1,j5,j6)`, `(j4,j2,j6)`, `(j4,j5,j3)`, and evaluate factorial terms in log space for stability.
- Dense LU kernels should pack `L` and `U` into a single `DenseComplexMatrix` with a permutation vector of source-row indices; solving requires applying that row permutation to `rhs` before forward/back substitution.
- Matrix inversion helpers should reuse `LuDecomposition::solve` over identity basis vectors and reject tiny LU pivots relative to `||A||_inf` to fail fast on ill-conditioned inputs.
- `faer` general eigensolver output ordering is unspecified; sort eigenpairs (value + matching vector column) by `(Re(lambda), Im(lambda))` before exposing deterministic APIs or comparing against reference spectra.
- FEFF `somm.f90` parity requires Simpson weights over `r^(m+1)` on the log-radius grid plus endpoint corrections from the first two radial points using the near-zero exponent parameter.
- FEFF `conv.f90` parity requires an extrapolated final interval with `dx = max(last_step, 50*broadening)` and a small-`|t|` polynomial branch for `conv1` when `|t| < 0.1`.
- Keep numerics cross-domain regression baselines in `tasks/math-regression-fixtures.json` and load them from integration tests so Bessel/harmonics/Wigner/linalg/integration/convolution checks share one fixture source.
- Exchange-model plumbing should map FEFF `ixc` through `numerics::exchange::ExchangeModel::from_feff_ixc` and invoke `ExchangePotentialApi::evaluate` in POT/XSPH compute paths while preserving existing placeholder output formulas until model kernels are ported.
- Keep EXCH regression baselines in `tasks/exchange-regression-fixtures.json` and validate them from `crates/feff-core/tests/exchange_regression.rs` to keep fixture-driven parity checks for all four exchange models.
- FEFF EXCH parity ports should convert electron density to `rs = (3/(4*pi*rho))^(1/3)` (fallback `rs=10` for non-positive density) and clamp normalized momentum `x=k/kf` to at least `1.00001` before evaluating `rhl`/`edp` formulas.
- FEFF local VBH/PZ exchange evaluators are real-only `rs` functions; keep `imaginary = 0` and use unpolarized `xmag = 1.0` parity when porting `vbh.f90` and `m_pz.f90`.
- FEFF COMMON physical constants should be centralized in `crates/feff-core/src/common/constants.rs`; import them from `crate::common::constants` (for example `PI`, `PI2`, `FA`) instead of repeating local literals.
- For large FEFF COMMON tables, store raw constants in `crates/feff-core/src/common/config_data.rs` and keep module code on typed lookups from `crates/feff-core/src/common/config.rs` so physics kernels do not index giant arrays directly.
- FEFF `getorb`-style extraction in Rust should preserve 1-based orbital table indices (`1..=40`) and provide a kappa projection lookup equivalent to Fortran `iorb(-5:4)` over occupied orbitals.

## 2026-02-17 22:00:24 JST - US-001
- Implemented `crates/feff-core/src/numerics/special/` scaffolding with public API surfaces for Bessel, spherical harmonics, and Wigner functions (`bessel.rs`, `harmonics.rs`, `wigner.rs`, `mod.rs`).
- Wired `special` through `crates/feff-core/src/numerics/mod.rs` and added `num-complex` + `faer` as workspace-backed dependencies in `Cargo.toml` and `crates/feff-core/Cargo.toml`.
- Files changed: `Cargo.toml`, `Cargo.lock`, `crates/feff-core/Cargo.toml`, `crates/feff-core/src/numerics/mod.rs`, `crates/feff-core/src/numerics/special/mod.rs`, `crates/feff-core/src/numerics/special/bessel.rs`, `crates/feff-core/src/numerics/special/harmonics.rs`, `crates/feff-core/src/numerics/special/wigner.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: `feff-core` dependency declarations follow workspace indirection (`*.workspace = true`) rather than pinning versions per crate.
  - Gotchas encountered: running `cargo fmt` from workspace root can touch many unrelated files; use targeted `rustfmt` for scoped story diffs.
  - Useful context: the new numerics home for upcoming Fortran parity kernels is `crates/feff-core/src/numerics/special/`, with APIs re-exported from `special/mod.rs`.
---

## 2026-02-17 22:07:37 JST - US-002
- Implemented FEFF-style complex spherical Bessel `j_l(z)` in `crates/feff-core/src/numerics/special/bessel.rs` with `bjnser`-style series evaluation for small arguments, downward recursion for the mid-range branch, and asymptotic polynomial basis/recurrence for large arguments.
- Added a public `spherical_j(order, argument)` API and re-exported it from `crates/feff-core/src/numerics/special/mod.rs`.
- Added unit tests covering `l=0..8` against independent complex reference vectors (small/mid/large argument regimes) with explicit absolute/relative tolerance assertions.
- Files changed: `crates/feff-core/src/numerics/special/bessel.rs`, `crates/feff-core/src/numerics/special/mod.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: FEFF parity for `j_l` depends on preserving `besjh.f90` branch boundaries and using `bjnser` seeds before recursion in the mid-range branch.
  - Gotchas encountered: `besjh` expects `Re(z) >= 0`; this port enforces the same precondition to avoid unsupported branch behavior drifting from Fortran.
  - Useful context: no repository-local `AGENTS.md` exists under this workspace, so reusable implementation notes were consolidated in this Ralph progress log.
---

## 2026-02-17 22:17:03 JST - US-003
- Implemented FEFF-parity complex spherical Neumann `spherical_n(order, argument)` and Hankel `spherical_h(order, argument)` APIs in `crates/feff-core/src/numerics/special/bessel.rs`, including `bjnser` Neumann series, mid-range recursion seeding, and large-argument asymptotic paths.
- Added `spherical_h1` as a compatibility alias to `spherical_h`, and re-exported `spherical_n`, `spherical_h`, and `spherical_h1` from `crates/feff-core/src/numerics/special/mod.rs`.
- Added FEFF reference-vector regression tests for `n_l` and `h_l` across small/mid/large arguments, including branch-cut sign behavior (`Im(z) > 0` vs `Im(z) < 0`) and large-argument cases generated from FEFF `besjn.f90` and `besjh.f90`.
- Files changed: `crates/feff-core/src/numerics/special/bessel.rs`, `crates/feff-core/src/numerics/special/mod.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: FEFF Hankel parity requires a dedicated asymptotic branch that switches phase/exponential sign by `Im(z)`; deriving Hankel only from `j + i*n` can lose FEFF parity for the negative-imaginary branch.
  - Gotchas encountered: running workspace-wide `cargo fmt` introduces large unrelated diffs; keep story scope by using targeted `rustfmt` on touched files.
  - Useful context: FEFF reference vectors for math kernels can be generated quickly by compiling small local Fortran harnesses against `feff10/src/MATH/{bjnser,besjn,besjh}.f90`.
---

## 2026-02-17 22:21:38 JST - US-004
- Implemented production spherical harmonics APIs in `crates/feff-core/src/numerics/special/harmonics.rs`: `y_lm(degree, order, theta, phi)` and `spherical_y(input)`, backed by associated Legendre recurrence, FEFF-compatible Condon-Shortley phase, and negative-order symmetry handling.
- Re-exported harmonics APIs from `crates/feff-core/src/numerics/special/mod.rs` so downstream numerics/scattering call paths can consume them directly.
- Added unit tests validating representative closed-form values plus required normalization and symmetry identities for representative `l,m` combinations.
- Files changed: `crates/feff-core/src/numerics/special/harmonics.rs`, `crates/feff-core/src/numerics/special/mod.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: the `harmonics.rs` API shape should expose both scalar-argument (`y_lm`) and struct-input (`spherical_y`) entry points, matching how existing numerics modules separate ergonomic and trait-oriented call sites.
  - Gotchas encountered: numerical identities are more stable with explicit absolute+relative tolerances; relying on strict equality for harmonic normalization/symmetry will produce flaky tests.
  - Useful context: this repository currently has no local `AGENTS.md` files, so reusable implementation guidance for numerics migrations should be captured in `scripts/ralph/progress.txt`.
---

## 2026-02-17 22:27:25 JST - US-005
- Implemented FEFF-convention Wigner 3j solver in `crates/feff-core/src/numerics/special/wigner.rs` as `wigner_3j(Wigner3jInput)` using doubled quantum numbers and the `cwig3j.f90` log-factorial summation/sign rules.
- Re-exported `wigner_3j` from `crates/feff-core/src/numerics/special/mod.rs` and added unit tests for selection-rule zeros plus tabulated integer/half-integer values (validated against FEFF `cwig3j.f90` outputs).
- Verified quality gates with `cargo check -p feff-core` and `cargo test -p feff-core`.
- Files changed: `crates/feff-core/src/numerics/special/wigner.rs`, `crates/feff-core/src/numerics/special/mod.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Wigner APIs in this codebase should consume doubled quantum numbers (`two_j*`, `two_m*`) to stay aligned with FEFF call sites and avoid repeated half-integer conversions.
  - Gotchas encountered: FEFF’s `cwig3j` factorial lookup is 1-indexed (`al(i)=ln((i-1)!)`); a direct 0-index `ln(i!)` translation causes wrong normalization.
  - Useful context: there are still no repository-local `AGENTS.md` files to update, so reusable numerics guidance continues to live in `scripts/ralph/progress.txt`.
---

## 2026-02-17 22:33:32 JST - US-006
- Implemented `wigner_6j(Wigner6jInput)` in `crates/feff-core/src/numerics/special/wigner.rs` using doubled-quantum-number Racah summation with explicit triangle/parity validation and log-factorial evaluation for numerical stability.
- Re-exported `wigner_6j` from `crates/feff-core/src/numerics/special/mod.rs` and added Wigner 6j unit tests covering selection-rule zeros plus known integer and half-integer reference values.
- Verified quality gates with `cargo check -p feff-core` and `cargo test -p feff-core`.
- Files changed: `crates/feff-core/src/numerics/special/wigner.rs`, `crates/feff-core/src/numerics/special/mod.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: selecting Racah’s `z` bounds from `max(j1+j2+j3, j1+j5+j6, j4+j2+j6, j4+j5+j3)` to `min(j1+j2+j4+j5, j1+j3+j4+j6, j2+j3+j5+j6)` (in integer units) keeps denominator factorial arguments non-negative.
  - Gotchas encountered: 6j validity requires both triangle inequalities and integer-sum parity on each of the four coupling triangles; missing the parity checks yields non-physical nonzero outputs for invalid half-integer combinations.
  - Useful context: there are still no repository-local `AGENTS.md` files, so reusable numerics migration guidance remains centralized in `scripts/ralph/progress.txt`.
---

## 2026-02-17 22:39:59 JST - US-007
- Implemented `crates/feff-core/src/numerics/special/linalg.rs` with dense complex LU factorization using partial pivoting (`lu_factorize`) and a linear-system solve path (`LuDecomposition::solve` and convenience `lu_solve`) backed by `faer::Mat` primitives.
- Wired LU APIs into `crates/feff-core/src/numerics/special/mod.rs` exports and added coverage for pivoting/recomposition, complex solve correctness, singular detection, and shape/`rhs` mismatch validation.
- Verified quality gates with `cargo check -p feff-core` and `cargo test -p feff-core`.
- Files changed: `crates/feff-core/src/numerics/special/linalg.rs`, `crates/feff-core/src/numerics/special/mod.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: storing pivot metadata as source-row indices (`pivots[row]`) keeps `P*A = L*U` reconstruction and `rhs` permutation straightforward for reuse in inversion helpers.
  - Gotchas encountered: mutating and reading the same `faer::Mat` element in one expression can trigger borrow conflicts; compute updated values in temporaries before assignment.
  - Useful context: there are still no repository-local `AGENTS.md` files under this workspace, so reusable LU guidance was captured in this progress log.
---

## 2026-02-17 22:43:38 JST - US-008
- Implemented dense matrix inversion for `DenseComplexMatrix` in `crates/feff-core/src/numerics/special/linalg.rs` via `LuDecomposition::invert` and `lu_invert`, reusing LU solve against identity basis vectors.
- Added an explicit ill-conditioning guard (`LuError::IllConditionedMatrix`) based on LU diagonal pivot magnitude relative to `||A||_inf`, plus `lu_invert` exposure through `crates/feff-core/src/numerics/special/mod.rs`.
- Added inversion regression tests for recomposition-to-identity and failure-path coverage for singular and ill-conditioned matrices.
- Verified quality gates with `cargo check -p feff-core` and `cargo test -p feff-core`.
- Files changed: `crates/feff-core/src/numerics/special/linalg.rs`, `crates/feff-core/src/numerics/special/mod.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: inversion should be layered on top of existing LU decomposition/solve instead of duplicating elimination logic.
  - Gotchas encountered: near-singular matrices can pass raw LU singular thresholds; adding a relative pivot check avoids unstable inverse outputs.
  - Useful context: there are still no repository-local `AGENTS.md` files in this workspace, so reusable numerics notes remain in `scripts/ralph/progress.txt`.
---

## 2026-02-17 22:49:39 JST - US-009
- Implemented a dense eigenvalue helper in `crates/feff-core/src/numerics/special/linalg.rs` with `EigenDecomposition`, `EigenError`, `eigen_decompose`, and `eigenvalues`, backed by `faer`'s `Mat::eigen()` API.
- Added deterministic eigenpair ordering (sort by `(Re(lambda), Im(lambda))` while reordering matching eigenvector columns) and exported the new APIs from `crates/feff-core/src/numerics/special/mod.rs`.
- Added regression tests covering shape validation, reference-spectrum checks on a scattering-style upper-triangular kernel, dense complex eigenpair residual checks (`A v ≈ λ v`), and a real-kernel complex-conjugate eigenvalue pair case.
- Verified quality gates with `cargo check -p feff-core` and `cargo test -p feff-core`.
- Files changed: `crates/feff-core/src/numerics/special/linalg.rs`, `crates/feff-core/src/numerics/special/mod.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: expose eigen helper outputs as paired `{eigenvalues, eigenvectors}` so downstream kernels can validate or consume eigenpairs without recomputing.
  - Gotchas encountered: `faer` does not guarantee general-eigensolver ordering; deterministic regression tests require explicit sorting of values and corresponding vector columns.
  - Useful context: eigenpair regression is most stable when asserting residuals (`||A v - λ v||`) with absolute+relative tolerances instead of relying only on exact vector orientation.
---

## 2026-02-17 22:59:33 JST - US-010
- Implemented FEFF `somm.f90`-parity radial integration in `crates/feff-core/src/numerics/special/integration.rs` via `integrate_somm`, including Simpson weighting over exponential radial grids and FEFF endpoint correction terms.
- Added reusable API surfaces (`SommInput`, `SommError`, `RadialIntegrationApi`) and exported them through `crates/feff-core/src/numerics/special/mod.rs`.
- Added deterministic regression tests covering analytic power-law integrals and two fixed Fortran fixture cases generated from `feff10/src/MATH/somm.f90`.
- Verified quality gates with `cargo check -p feff-core` and `cargo test -p feff-core`.
- Files changed: `crates/feff-core/src/numerics/special/integration.rs`, `crates/feff-core/src/numerics/special/mod.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: keep FEFF parity by splitting positive/negative accumulations separately before combining, matching `somm.f90` arithmetic-if behavior.
  - Gotchas encountered: `somm.f90` treats `m` as integer (`implicit` I-N rule); using floating `m` changes exponent behavior and breaks parity.
  - Useful context: FEFF source is available locally at `feff10/src/MATH/somm.f90`, which is the right baseline for future integration/convolution fixture generation.
---

## 2026-02-17 23:06:36 JST - US-011
- Implemented FEFF `conv.f90`-parity spectrum helpers in `crates/feff-core/src/numerics/special/convolution.rs`: `convolve_lorentzian` (analytic interval convolution with high-energy extrapolation) and `interpolate_spectrum_linear` (complex linear interpolation with boundary clamping).
- Added typed API surfaces (`LorentzianConvolutionInput`, `SpectralInterpolationInput`, `ConvolutionError`, `SpectralConvolutionApi`) and exported them from `crates/feff-core/src/numerics/special/mod.rs`.
- Added unit tests for interpolation boundary handling and validation errors, plus convolution parity against independent Simpson-quadrature reference integrals and explicit high-energy extension behavior on representative spectra arrays.
- Verified quality gates with `cargo check -p feff-core` and `cargo test -p feff-core`.
- Files changed: `crates/feff-core/src/numerics/special/convolution.rs`, `crates/feff-core/src/numerics/special/mod.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: FEFF convolution parity depends on appending an extrapolated final segment using `dx = max(last_step, 50*broadening)` before evaluating interval integrals.
  - Gotchas encountered: interval integration needs the small-`|t|` branch (`|t| < 0.1`) to avoid instability in `log((1+t)/(1-t))`.
  - Useful context: there are still no repository-local `AGENTS.md` files in this workspace, so reusable convolution guidance remains centralized in `scripts/ralph/progress.txt`.
---

## 2026-02-17 23:15:09 JST - US-012
- Added consolidated MATH regression fixtures at `tasks/math-regression-fixtures.json` for Bessel (`j/n/h`), spherical harmonics, Wigner (`3j/6j`), LU solve/invert, eigenvalues, `somm` integration, and convolution/interpolation reference outputs.
- Added `crates/feff-core/tests/math_primitives_regression.rs` to load fixture JSON and assert all numerics primitive APIs against per-case absolute/relative tolerances.
- Verified quality gates with `cargo check -p feff-core` and `cargo test -p feff-core`.
- Files changed: `tasks/math-regression-fixtures.json`, `crates/feff-core/tests/math_primitives_regression.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: when adding new numerics primitives, extend `tasks/math-regression-fixtures.json` and `crates/feff-core/tests/math_primitives_regression.rs` instead of creating isolated one-off fixture formats.
  - Gotchas encountered: this workspace still has no local `AGENTS.md`, so reusable module patterns must be captured in `scripts/ralph/progress.txt`.
  - Useful context: integration tests resolve fixture files from workspace root via `CARGO_MANIFEST_DIR` parent traversal, matching existing parity-test conventions.
---

## 2026-02-17 23:21:13 JST - US-013
- Added `crates/feff-core/src/numerics/exchange/mod.rs` with shared exchange API scaffolding: `ExchangeModel`, `ExchangeEvaluationInput`, `ExchangeEvaluation`, `ExchangePotentialApi`, and a default `ExchangePotential` evaluator entrypoint.
- Wired the new numerics module through `crates/feff-core/src/numerics/mod.rs` and threaded exchange API entrypoints through POT/XSPH call paths by mapping FEFF `ixc` values and invoking the evaluator from `PotModel::potential_metrics` and `XsphModel::output_config`.
- Preserved existing POT/XSPH physics outputs for this story by keeping current placeholder formulas unchanged after adding the new exchange API hooks.
- Verified quality gates with `cargo check -p feff-core` and `cargo test -p feff-core`.
- Files changed: `crates/feff-core/src/numerics/exchange/mod.rs`, `crates/feff-core/src/numerics/mod.rs`, `crates/feff-core/src/modules/pot/model.rs`, `crates/feff-core/src/modules/xsph/parser.rs`, `crates/feff-core/src/modules/xsph/model.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: keep FEFF `ixc` parsing in module-specific parsers (`pot`/`xsph`) and convert to shared numerics model enums at model-construction boundaries.
  - Gotchas encountered: this story intentionally leaves the exchange evaluator returning zero placeholders to avoid output drift before model-specific kernel ports (`US-014`/`US-015`).
  - Useful context: no repository-local `AGENTS.md` files exist in this workspace, so reusable module conventions remain documented in `scripts/ralph/progress.txt`.
---

## 2026-02-17 23:29:01 JST - US-014
- Implemented FEFF-parity Hedin-Lundqvist and Dirac-Hara evaluators in `crates/feff-core/src/numerics/exchange/mod.rs` by porting `rhl.f90`/`imhl.f90`/`edp.f90` logic (including Quinn damping, cubic-root branch handling, and FEFF interpolation coefficient tables).
- Updated `ExchangePotentialApi::evaluate` to execute model-specific kernels for `HedinLundqvist` and `DiracHara` while leaving `VonBarthHedin`/`PerdewZunger` as zero placeholders until `US-015`.
- Added unit tests with explicit FEFF reference samples for both HL and DH model outputs (real/imaginary components) and verified quality gates with `cargo check -p feff-core` and `cargo test -p feff-core`.
- Files changed: `crates/feff-core/src/numerics/exchange/mod.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: when porting Fortran multi-dimensional coefficient tables (`rcfl`/`rcfr`), preserve original column-major data ordering and index explicitly rather than transposing literals.
  - Gotchas encountered: round-tripping `rs` through density conversion introduces small floating-point drift, so FEFF reference assertions should use realistic tolerances (order `1e-7`) instead of ultra-tight equality.
  - Useful context: FEFF EXCH reference vectors can be regenerated locally by compiling `m_constants.f90`, `m_par.f90`, `EXCH/{cubic,ffq,imhl,rhl,edp}.f90`, and `SELF/quinn.f90` in a small harness.
---

## 2026-02-17 23:35:28 JST - US-015
- Implemented FEFF-parity Von Barth-Hedin and Perdew-Zunger evaluators in `crates/feff-core/src/numerics/exchange/mod.rs` by porting `EXCH/vbh.f90` (`flarge` + unpolarized `xmag=1.0` path) and `EXCH/m_pz.f90` (`slater` + `pz(iflag=1)` potential equations).
- Updated `ExchangePotentialApi::evaluate` model dispatch so `ExchangeModel::VonBarthHedin` and `ExchangeModel::PerdewZunger` return real kernel outputs instead of placeholder zeros, and expanded `from_feff_ixc` coverage checks for `ixc=7/8`.
- Added unit tests for VBH/PZ FEFF reference-vector parity and explicit model-selection differentiation, then verified quality gates with `cargo check -p feff-core` and `cargo test -p feff-core`.
- Files changed: `crates/feff-core/src/numerics/exchange/mod.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: VBH/PZ parity tests can reuse the shared `density -> rs` transform and validate only the real channel because both evaluators are ground-state local potentials with zero imaginary part.
  - Gotchas encountered: compiling Fortran harnesses for reference vectors can emit transient module artifacts (`*.mod`) in repo root; remove them before committing.
  - Useful context: FEFF VBH/PZ reference samples can be regenerated with a minimal harness that links `feff10/src/EXCH/vbh.f90` and `feff10/src/EXCH/m_pz.f90`.
---

## 2026-02-17 23:39:10 JST - US-016
- Added EXCH regression fixtures at `tasks/exchange-regression-fixtures.json` covering all four exchange models (Hedin-Lundqvist, Dirac-Hara, Von Barth-Hedin, Perdew-Zunger) with deterministic fixed-input expected outputs.
- Added `crates/feff-core/tests/exchange_regression.rs` to load the fixture file, assert tolerance-based parity for real/imaginary channels, and verify deterministic repeat evaluation per case.
- Verified quality gates with `cargo check -p feff-core` and `cargo test -p feff-core`.
- Files changed: `tasks/exchange-regression-fixtures.json`, `crates/feff-core/tests/exchange_regression.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: keep EXCH reference values fixture-driven in `tasks/exchange-regression-fixtures.json` and validate through one integration test file (`crates/feff-core/tests/exchange_regression.rs`) to avoid duplicating model-specific constants across unit tests.
  - Gotchas encountered: `ExchangeModel` is not serde-deserializable, so fixture tests should deserialize into a local fixture enum and map to `ExchangeModel` explicitly.
  - Useful context: integration tests in this workspace resolve `tasks/*` fixtures by traversing two parents from `CARGO_MANIFEST_DIR` (crate dir -> workspace root), matching existing regression-test conventions.
---

## 2026-02-17 23:46:57 JST - US-017
- Added a new COMMON constants module at `crates/feff-core/src/common/constants.rs` and exported it through `crates/feff-core/src/common/mod.rs` plus `crates/feff-core/src/lib.rs`.
- Ported physics-critical values from `feff10/src/COMMON/m_constants.f90` (pi/pi2, fa, bohr/ryd/hart, fine-structure and unit-conversion constants) with coverage tests for key relationships/validity.
- Replaced duplicated ad hoc constants in core paths by importing shared constants in `crates/feff-core/src/numerics/exchange/mod.rs`, `crates/feff-core/src/numerics/special/harmonics.rs`, and `crates/feff-core/src/modules/compton/parser.rs`.
- Verified quality gates with `cargo check -p feff-core` and `cargo test -p feff-core`.
- Files changed: `crates/feff-core/src/common/mod.rs`, `crates/feff-core/src/common/constants.rs`, `crates/feff-core/src/lib.rs`, `crates/feff-core/src/numerics/exchange/mod.rs`, `crates/feff-core/src/numerics/special/harmonics.rs`, `crates/feff-core/src/modules/compton/parser.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: `common/constants.rs` is the canonical source for FEFF COMMON constants, and modules should import from it instead of defining duplicate local `PI`/`FA` values.
  - Gotchas encountered: running `rustfmt` on module roots like `lib.rs` can cascade into unrelated child files; keep story diffs scoped by formatting only touched leaf files.
  - Useful context: there are still no repository-local `AGENTS.md` files under this workspace, so reusable implementation notes remain tracked in `scripts/ralph/progress.txt`.
---

## 2026-02-17 23:54:28 JST - US-018
- Ported `m_config.f90` electronic-configuration defaults into Rust as `crates/feff-core/src/common/config_data.rs`, including FEFF9/FEFF7 occupation+valence tables, FEFF9 spin defaults, orbital `kappa`/`nnum`, noble-gas rows, and element symbols for `Z=1..139`.
- Added typed atomic-number lookup APIs in `crates/feff-core/src/common/config.rs` (`feff9_for_atomic_number`, `feff7_for_atomic_number`, symbol/Z helpers, and orbital metadata accessors) with coverage for bounds, known-reference rows, and electron-count invariants.
- Wired POT to consume FEFF9 configuration lookup data inside `PotModel::potential_metrics` so POT effective quantities are derived from the ported COMMON dataset rather than raw `Z` only.
- Verified quality gates with `cargo check -p feff-core` and `cargo test -p feff-core`.
- Files changed: `crates/feff-core/src/common/mod.rs`, `crates/feff-core/src/common/config.rs`, `crates/feff-core/src/common/config_data.rs`, `crates/feff-core/src/modules/pot/model.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: expose COMMON datasets through a narrow API (`common/config.rs`) and keep large static tables isolated (`common/config_data.rs`) to simplify downstream module integration.
  - Gotchas encountered: running `rustfmt` on module roots can reformat sibling files; use targeted file lists and confirm `git status` before committing.
  - Useful context: there are still no repository-local `AGENTS.md` files, so reusable migration guidance remains centralized in `scripts/ralph/progress.txt`.
---

## 2026-02-18 00:00:08 JST - US-019
- Implemented `getorb`-equivalent orbital extraction helpers in `crates/feff-core/src/common/config.rs`: `getorb_for_atomic_number`, `orbital_metadata`, `orbital_occupancy_for_atomic_number`, and shell-targeted lookup via `shell_orbitals_for_atomic_number`.
- Added FEFF orbital/shell domain types (`ElectronShell`, `OrbitalMetadata`, `OrbitalOccupancy`, `OrbitalExtraction`) including a kappa projection accessor equivalent to Fortran `iorb(-5:4)` for occupied states.
- Added unit tests covering representative K/L/M shell lookups and projection behavior (`common::config::tests::{getorb_metadata_reports_quantum_numbers_and_shell,getorb_shell_lookup_supports_k_l_and_m_shell_queries,getorb_projection_lookup_matches_last_occupied_kappa_orbitals}`).
- Verified quality gates with `cargo check -p feff-core` and `cargo test -p feff-core`.
- Files changed: `crates/feff-core/src/common/config.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: model FEFF orbital extraction on occupied-state compaction plus a kappa-indexed projection lookup, not on raw full-table scans in downstream physics modules.
  - Gotchas encountered: this environment exposes `python3` but not `python`; use `jq` or `python3` for PRD/progress automation scripts.
  - Useful context: K/L/M shell selection can be derived directly from `nnum` (`n=1/2/3`) while preserving FEFF orbital index ordering for deterministic edge-related lookups.
---
