# Ralph Progress Log
Started: Mon Feb 16 16:57:34 JST 2026
## Codebase Patterns
- Store migration governance decisions under `tasks/` and add a reference from `tasks/prd-migrate-feff10-to-rust-improved.md` for traceability.
- Keep story state consistent by updating `scripts/ralph/prd.json` (`passes`) and appending `scripts/ralph/progress.txt` in the same commit.
- For cross-cutting migration decisions, include explicit architecture and CI implications in `tasks/migration-decision-log.md` and mirror the decision status in PRD references.
- When a policy must be machine-consumable, keep a canonical JSON artifact under `tasks/` and document comparator ingestion rules alongside the approval decision.
- For warning/error compatibility decisions, define all three together: exit-code matrix, stderr/stdout formatting contract, and legacy failure-class to Rust error-category mapping.
- Compatibility matrix rows belong in `tasks/feff10-compatibility-matrix.md` and should always include command surface, required cards/options, input/output artifacts, output directory contract, and fixture IDs.
- Fixture manifests should be machine-readable JSON under `tasks/`, must reuse reserved `FX-*` IDs from the compatibility matrix, and must define `comparison.mode` plus `comparison.passFailThreshold` per fixture.
- Baseline capture tooling should treat manifest `entryFiles` as authoritative and materialize `REFERENCE/<file>` inputs from `baselineSources` archives into a flat fixture working directory.
- Baseline snapshot generation should run all fixtures via `scripts/fortran/generate-baseline-snapshots.sh` and emit per-fixture `checksums.sha256` plus `snapshot-metadata.json` under `artifacts/fortran-baselines/`.
- Regression harness fixture layout is `<root>/<fixture-id>/<subdir>`; keep Rust output staging compatible with `--actual-root` plus `--actual-subdir` for `feff10-rs regression`.
- Numeric-tolerance policy globs must only target parseable numeric files; non-numeric headers in matched files (for example `paths.dat`) are reported as comparison failures.
- On this macOS environment, run Rust tests with `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)"` to avoid `ld: library not found for -liconv` from the default linker.
- Keep `src/main.rs` as a thin process entrypoint and route command parsing through `src/cli`, with scientific and regression execution logic grouped under `src/pipelines` and shared contracts in `src/domain`.
- Shared runtime failure handling lives in `src/domain/errors.rs`; parser and pipeline APIs should return `ParserResult`/`PipelineResult`, and CLI fatal output should emit both `ERROR: [TOKEN] ...` and `FATAL EXIT CODE: <n>` from one mapping point.
---
## 2026-02-16 17:00:00 JST - US-001
- Implemented the D-1 platform certification matrix with GA/non-GA OS+architecture targets, platform-specific compiler/runtime constraints, and an explicit approval record.
- Added a PRD traceability reference to the finalized D-1 decision log.
- Quality checks: `cargo check` passed.
- Files changed: `tasks/migration-decision-log.md`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Decision-level migration constraints should live in dedicated docs under `tasks/` and be linked from the PRD.
  - Gotchas encountered: `scripts/ralph/progress.txt` may start without a `Codebase Patterns` section; create it at the top before appending story entries.
  - Useful context: Story execution state is controlled only by `passes` in `scripts/ralph/prd.json`; update just the completed story.
---
## 2026-02-16 17:08:01 JST - US-002
- Implemented decision `D-2` in `tasks/migration-decision-log.md`, explicitly deferring MPI parity for v1 and documenting fallback behavior plus a roadmap trigger.
- Added MPI decision traceability in `tasks/prd-migrate-feff10-to-rust-improved.md`, including architecture-planning and CI-planning references to the approved D-2 scope.
- Quality checks: `cargo check` and `cargo test` passed.
- Files changed: `tasks/migration-decision-log.md`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: MPI-scope decisions should include explicit fallback behavior and a concrete re-open trigger so later parity work has clear entry criteria.
  - Gotchas encountered: Acceptance for decision stories can require references in multiple planning surfaces; update both architecture and CI sections, not only the decision log.
  - Useful context: In this repo, architecture and CI planning context is captured in `tasks/prd-migrate-feff10-to-rust-improved.md`, so D-2 references belong there as well as in the decision log.
---
## 2026-02-16 17:11:56 JST - US-003
- Implemented decision `D-3` in `tasks/migration-decision-log.md` with an output-category policy matrix that defines exact-text vs numeric-tolerance comparison modes and approved absolute/relative tolerances.
- Added machine-readable comparator policy file `tasks/numeric-tolerance-policy.json`, including category match order, numeric parsing rules, and per-category thresholds.
- Added D-3 traceability in `tasks/prd-migrate-feff10-to-rust-improved.md`, pointing to both the decision log and the JSON policy artifact.
- Quality checks: `cargo check` and `cargo test` passed; `jq empty tasks/numeric-tolerance-policy.json` passed.
- Files changed: `tasks/migration-decision-log.md`, `tasks/numeric-tolerance-policy.json`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Comparator-facing governance decisions should include both a human-readable matrix in the decision log and a canonical machine-readable JSON file.
  - Gotchas encountered: Category ordering now matters (`first_match`); broad glob patterns must be kept below specific patterns to avoid unintended rule capture.
  - Useful context: Numeric parsing explicitly supports Fortran `D` exponents and defaults unmatched files to `exact_text`, which future comparator implementation should preserve.
---
## 2026-02-16 17:14:46 JST - US-004
- Implemented decision `D-4` in `tasks/migration-decision-log.md` with a finalized warning/error compatibility contract, including exit-code mapping for success/failure modes, deterministic stderr/stdout behavior, and legacy failure-class mapping to Rust error categories.
- Added architecture and CI implications for `D-4` to keep downstream implementation and validation stories aligned with the contract.
- Added D-4 traceability in `tasks/prd-migrate-feff10-to-rust-improved.md`.
- Quality checks: `cargo check` and `cargo test` passed.
- Files changed: `tasks/migration-decision-log.md`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Warning/error compatibility must capture both process semantics (exit code) and text-stream semantics (`stderr`/`stdout` prefixes) to avoid breaking legacy automation.
  - Gotchas encountered: For compatibility stories, acceptance can require explicit mapping tables (legacy class to Rust category), not only prose decisions.
  - Useful context: `D-4` now reserves exit codes `2`-`5` for fatal categories and keeps warning-only runs at exit code `0`.
---
## 2026-02-16 17:21:39 JST - US-005
- Published canonical compatibility matrix `tasks/feff10-compatibility-matrix.md` covering all in-scope modules with required CLI surfaces, options/cards, input/output artifacts, output directory contracts, and fixture traceability IDs.
- Added PRD traceability references to the compatibility matrix in `tasks/prd-migrate-feff10-to-rust-improved.md`.
- Quality checks: `cargo check` and `cargo test` passed.
- Files changed: `tasks/feff10-compatibility-matrix.md`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Compatibility matrix deliverables should keep module contracts in one canonical document under `tasks/` and include fixture IDs that future manifest work must reuse verbatim.
  - Gotchas encountered: Some scoped modules (`DEBYE`, `SELF`) do not have standalone executables; their CLI contracts are through host modules (`ff2x` and `sfconv`) and must be modeled that way.
  - Useful context: The matrix is grounded in Fortran module headers plus source-level `open(file=...)` contracts, which gives a concrete baseline for later regression harness implementation.
---
## 2026-02-16 17:28:30 JST - US-006
- Created canonical fixture manifest `tasks/golden-fixture-manifest.json` with all reserved fixture IDs, including at least one fixture per in-scope module and end-to-end workflow fixture `FX-WORKFLOW-XAS-001`.
- Added per-fixture comparison contracts (`comparison.mode` and `comparison.passFailThreshold`) and documented four edge-case fixtures (`FX-RIXS-001`, `FX-DMDW-001`, `FX-SCREEN-001`, `FX-FULLSPECTRUM-001`).
- Added PRD traceability status in `tasks/prd-migrate-feff10-to-rust-improved.md` for the published fixture manifest.
- Quality checks: `jq empty tasks/golden-fixture-manifest.json`, `cargo check`, and `cargo test` passed.
- Files changed: `tasks/golden-fixture-manifest.json`, `tasks/prd-migrate-feff10-to-rust-improved.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Fixture definitions are most reusable when each fixture includes module coverage, concrete input paths, baseline source metadata, and explicit comparison/pass-threshold settings.
  - Gotchas encountered: Some module fixtures (`BAND`, `FULLSPECTRUM`) have seed inputs in reference archives but require dedicated Fortran baseline capture in later stories; this iteration assumes that is acceptable because baseline generation is scoped to `US-007` and `US-008`.
  - Useful context: `feff10/examples/MPSE/Cu_OPCONS/REFERENCE.zip` contains both `screen.inp` and `sfconv.inp` plus `logscreen.dat`/`logsfconv.dat`, making it the best shared source for `SCREEN` and `SELF` fixture coverage.
---
## 2026-02-16 17:37:04 JST - US-007
- Implemented `scripts/fortran/capture-baselines.sh` to read `tasks/golden-fixture-manifest.json`, select fixtures (`--fixture`/`--fixtures`/`--all-fixtures`, defaulting to `requires_fortran_capture`), stage deterministic per-fixture `inputs/`, `outputs/`, and `logs/` directories, and execute Fortran captures through either `--runner` or `--bin-dir`.
- Added strict failure handling so any fixture materialization or execution error is reported and causes a non-zero process exit after summary reporting.
- Added `scripts/fortran/tests/test-capture-baselines.sh` to validate deterministic output-tree resets and non-zero exit behavior when a fixture run fails.
- Quality checks: `cargo check`, `cargo test`, and `scripts/fortran/tests/test-capture-baselines.sh` passed.
- Files changed: `scripts/fortran/capture-baselines.sh`, `scripts/fortran/tests/test-capture-baselines.sh`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: For capture automation, `--runner` mode is the lowest-friction integration path when teams already have a stable Fortran orchestration command.
  - Gotchas encountered: `FX-BAND-001` currently references `REFERENCE/band.inp`, but that file is absent from `feff10/examples/KSPACE/Cr2GeC/REFERENCE.zip`; default capture therefore reports a fixture failure until that input contract is corrected.
  - Useful context: With `set -o pipefail`, archive-entry checks should avoid `grep -q` on `unzip -Z1` pipelines to prevent false negatives from SIGPIPE.
---
## 2026-02-16 17:47:02 JST - US-008
- Implemented `scripts/fortran/generate-baseline-snapshots.sh` to run capture for `--all-fixtures`, materialize baseline artifacts from fixture `baselineSources` (`reference_archive` and `reference_file`), and write committed fixture snapshots under `artifacts/fortran-baselines/`.
- Added reproducibility metadata for each fixture via `checksums.sha256` and `snapshot-metadata.json`, plus top-level snapshot index `artifacts/fortran-baselines/snapshot-index.json`.
- Extended `scripts/fortran/capture-baselines.sh` with `--allow-missing-entry-files` so full-manifest capture can proceed while recording unresolved entries in metadata.
- Documented snapshot regeneration command and prerequisites in `README.md`.
- Quality checks: `cargo check`, `cargo test`, `scripts/fortran/tests/test-capture-baselines.sh`, and `scripts/fortran/tests/test-generate-baseline-snapshots.sh` passed.
- Files changed: `README.md`, `scripts/fortran/capture-baselines.sh`, `scripts/fortran/generate-baseline-snapshots.sh`, `scripts/fortran/tests/test-capture-baselines.sh`, `scripts/fortran/tests/test-generate-baseline-snapshots.sh`, `artifacts/fortran-baselines/*`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Snapshot generation should copy seeded capture outputs first, then overlay `baselineSources` so archive/file references become the canonical baseline view per fixture.
  - Gotchas encountered: `FX-BAND-001` still lacks `REFERENCE/band.inp` in its source archive; this run records it under `missingEntryFiles` while retaining a checksumed baseline from available artifacts.
  - Useful context: `snapshot-index.json` now contains `checksummedFileCount` and `missingEntryFiles` for every fixture, which can be consumed by upcoming comparator/runner stories.
---
## 2026-02-16 17:55:42 JST - US-009
- Implemented Rust comparator core in `src/comparator.rs`, including policy loading from JSON, ordered glob-based rule selection, and per-artifact exact-text or numeric-tolerance evaluation.
- Added structured comparison outputs (`ArtifactComparisonResult` + metrics enums) and batch comparison support via `Comparator::compare_artifacts`.
- Added unit tests for policy ingestion, first-match category behavior, exact-text mismatch reporting, numeric tolerance pass/fail behavior, Fortran `D` exponent parsing, and per-artifact result aggregation.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `Cargo.toml`, `Cargo.lock`, `src/lib.rs`, `src/comparator.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Comparator policy matching should preserve category order (`first_match`), so broad globs must be placed below specific globs.
  - Gotchas encountered: On this machine, plain `cargo test` fails to link `-liconv`; use the clang linker override command from `Codebase Patterns`.
  - Useful context: `Comparator::compare_artifacts` already yields structured per-artifact results, so `US-010` can consume it directly for summary/report generation.
---
## 2026-02-16 18:03:49 JST - US-010
- Implemented regression runner core in `src/regression.rs`, including manifest-driven fixture enumeration, per-artifact comparison against baselines using `Comparator`, fixture-level threshold evaluation, human-readable summary rendering, and JSON report emission.
- Replaced `src/main.rs` with a real CLI command (`feff10-rs regression`) that runs all fixtures in one command, supports configurable manifest/policy/root/subdir/report paths, and exits with status `1` when any fixture fails.
- Added regression coverage with unit tests in `src/regression.rs` and integration CLI tests in `tests/regression_cli.rs` to verify summary/report behavior and non-zero exit on failures.
- Documented runner invocation and report output in `README.md`.
- Quality checks: `cargo fmt --all`, `cargo check`, `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test`, and `cargo run -- regression` (expected non-zero with current policy/file-match set) completed.
- Files changed: `README.md`, `src/lib.rs`, `src/main.rs`, `src/regression.rs`, `tests/regression_cli.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Keep generated Rust fixture outputs in a deterministic `<root>/<fixture-id>/<subdir>` layout so they can be consumed directly by `feff10-rs regression --actual-root ... --actual-subdir ...`.
  - Gotchas encountered: Current numeric policy matches `paths.dat` under numeric tolerance, but those files include non-numeric tokens; the runner will correctly mark these as failures until policy globs or file formatting are aligned.
  - Useful context: Default runner config compares `artifacts/fortran-baselines/<fixture>/baseline` to the same layout and writes machine-readable results to `artifacts/regression/report.json`; pass real Rust outputs via `--actual-root`/`--actual-subdir`.
---
## 2026-02-16 18:09:01 JST - US-011
- Implemented Rust workspace scaffolding boundaries in the main crate by adding dedicated modules for `cli`, `domain`, `parser`, `numerics`, and `pipelines`.
- Moved comparator/regression infrastructure into `src/pipelines/` and kept behavior stable by routing binary startup through `src/cli::run_from_env()` with a thin `src/main.rs`.
- Added shared domain contracts (`PipelineModule`, `PipelineRequest`, input deck/card types), parser scaffolding entrypoint, numerics helper primitives, and pipeline abstraction interfaces with focused unit tests.
- Documented the scaffolded architecture layout in `README.md` to keep future module-port stories aligned with the PRD boundary guidance.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `README.md`, `src/lib.rs`, `src/main.rs`, `src/cli/mod.rs`, `src/domain/mod.rs`, `src/parser/mod.rs`, `src/numerics/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/comparator.rs`, `src/pipelines/regression.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Shared FEFF contracts should live in `src/domain`, and runtime orchestration code should remain isolated under `src/pipelines` so module ports can plug into stable interfaces.
  - Gotchas encountered: `cargo test` still requires the clang linker override on this macOS host; keep using the environment variable from `Codebase Patterns`.
  - Useful context: Existing regression behavior is now accessed through `crate::pipelines::regression`, so future pipeline stories can evolve module execution without changing CLI argument contracts.
---
## 2026-02-16 18:15:21 JST - US-012
- Implemented shared error/result infrastructure in `src/domain/errors.rs`, including D-4-aligned category enum (`Success`, `InputValidationError`, `IoSystemError`, `ComputationError`, `InternalError`), shared result aliases, and compatibility placeholder mapping (`exit_code`, Rust category token, legacy class token).
- Integrated shared error conventions across parser and pipeline surfaces by switching `parse_input_deck` to `ParserResult<InputDeck>`, updating `PipelineExecutor` to `PipelineResult`, and making `run_regression` return `PipelineResult<RegressionRunReport>`.
- Added error-category bridging from comparator/regression internals to shared `FeffError`, and centralized CLI fatal diagnostics/exit behavior to emit `ERROR: [TOKEN] ...` plus `FATAL EXIT CODE: <n>` via shared mapping.
- Quality checks: `cargo fmt --all`, `cargo check`, and `CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER="$(xcrun -f clang)" cargo test` passed.
- Files changed: `src/domain/errors.rs`, `src/domain/mod.rs`, `src/parser/mod.rs`, `src/pipelines/mod.rs`, `src/pipelines/comparator.rs`, `src/pipelines/regression.rs`, `src/cli/mod.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered: Shared parser/pipeline APIs should return `ParserResult`/`PipelineResult` aliases so compatibility exit mapping remains centralized in `FeffError`.
  - Gotchas encountered: `run_regression` now returns shared `FeffError`; callers that previously expected `RegressionRunnerError` should handle categorized errors instead of internal variants.
  - Useful context: CLI runtime errors now derive exit code from `FeffError::exit_code()` and print the D-4-compatible diagnostic pair, while parity mismatches still return `Ok(1)` without fatal-error formatting.
---
